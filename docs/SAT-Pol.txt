-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package SAT-Pol
@version 0.1.0.0


-- | This module contains several examples in order to verify the good
--   functioning of the other modules.
module Examples
x1 :: LexPoly F2 String
example :: [LexPoly F2 String]
exampleSet :: Set (LexPoly F2 String)
exampleMonomial1 :: Lex v
exampleMonomial2 :: Lex [Char]
exampleMonomial3 :: Lex [Char]
ej2 :: Vect F2 (Lex String)
ej1 :: LexPoly F2 String
ej3 :: LexPoly F2 String

module PolAux

-- | cleanExp aims to select the representative with leastest degree of a
--   polynomial in the quotient group
--   F2[x_1,...,x_N]/(x_1+x_1^2,...,x_N+x_N^2) . The main idea is to
--   replace every ocurrence of x_i^M with x_i thus we obtain an identical
--   polynomial without exponents greater than 1.
--   
--   In the library HaskellForMaths exists a function that performs the
--   same (%%) so we can check the results. For example,
--   
--   <pre>
--   &gt;&gt;&gt; cleanExp (x1^3)
--   x1
--   
--   &gt;&gt;&gt; (x1^3) %% [x1^2+x1]
--   x1
--   
--   &gt;&gt;&gt; cleanExp (x1^3*x2^6+x3^2*x4+x1+1)
--   x1x2+x1+x3x4+1
--   
--   &gt;&gt;&gt; let pol = x1^3*x2^6+x3^2*x4+x1+1
--   
--   &gt;&gt;&gt; let list = [x1^2+x1,x2^2+x2,x3^2+x3,x4^2+x4]
--   
--   &gt;&gt;&gt; pol %% list
--   x1x2+x1+x3x4+1
--   </pre>
cleanExp :: Vect F2 (Lex String) -> Vect F2 (Lex String)

-- | deriv calculates the derivative of the polynomial p with respect to
--   the variable v. It's important to note that deriv only works if it
--   applies to polynomials without exponents greater than 1. In practice,
--   deriv will only be used with polynomials that have been previously
--   "cleaned". For example:
--   
--   <pre>
--   &gt;&gt;&gt; let v = x1
--   
--   &gt;&gt;&gt; deriv v v
--   1
--   
--   &gt;&gt;&gt; deriv (1+x1+x2+x1*x2) v
--   x2+1
--   
--   &gt;&gt;&gt; deriv (x1*x2+x1+x3*x4+1) v
--   x2+1
--   </pre>
deriv :: Vect F2 (Lex String) -> Vect F2 (Lex String) -> Vect F2 (Lex String)


-- | This module aims to provide an efficient tool to solve the SAT
--   problem. Both the algorithm and the implementation have been carried
--   out by the researchers from the department of Computer Science and
--   Artificial Intelligence at the University of Seville.
module Tool

-- | tool decides if the set of formulas that produced the set of
--   polynomials were satisfiables. The function input is a list of
--   polynomials because the transformation from formula to polynomial is
--   handled by ReadingF.hs module.
tool :: [Vect F2 (Lex String)] -> Bool

-- | varsList xs return the set of variables which occurs in any polynomial
--   of the list xs. For example, the trivial case:
--   
--   <pre>
--   &gt;&gt;&gt; let xs = (take 10 (map (var . (\n -&gt; 'x':n) . show) [1..])) :: [LexPoly F2 String]
--   
--   &gt;&gt;&gt; xs
--   [x1,x2,x3,x4,x5,x6,x7,x8,x9,x10]
--   
--   &gt;&gt;&gt; varsList xs
--   [x1,x2,x3,x4,x5,x6,x7,x8,x9,x10]
--   
--   &gt;&gt;&gt; varsList [x1*x2+x2,x1+x1*x3,x1*x4*x2]
--   [x1,x2,x3,x4]
--   </pre>
varsList :: (Foldable t, Num k, MonomialConstructor m, Ord (m v), Ord k) => t (Vect k (m v)) -> [Vect k (m v)]


-- | This module aims to provide an efficient tool to solve the SAT
--   problem. Both the algorithm and the implementation have been carried
--   out by the researchers from the department of Computer Science and
--   Artificial Intelligence at the University of Seville.
module ToolS

-- | tool decides if the set of formulas that produced the set of
--   polynomials were satisfiables. The function input is a list of
--   polynomials because the transformation from formula to polynomial is
--   handled by ReadingF.hs module.
toolS :: Set (Vect F2 (Lex String)) -> Bool
toolSP' :: (Set (Vect F2 (Lex String)), Set (Vect F2 (Lex String))) -> Bool


-- | This module aims to provide an efficient tool to solve the SAT
--   problem. Both the algorithm and the implementation have been carried
--   out by the researchers from the department of Computer Science and
--   Artificial Intelligence at the University of Seville.
module ToolSP

-- | tool decides if the set of formulas that produced the set of
--   polynomials were satisfiables. The function input is a list of
--   polynomials because the transformation from formula to polynomial is
--   handled by ReadingF.hs module.
toolSP :: (Set (Vect F2 (Lex String), Set (Vect F2 (Lex String))), Set (Vect F2 (Lex String))) -> Bool

module ReadingF
main1 :: FilePath -> IO ()
main2 :: FilePath -> IO ()
cleanP :: (Vect F2 (Lex String), t) -> (Vect F2 (Lex String), t)
insertP :: (Ord a, Ord a1) => (a1, Set a) -> (Set a1, Set a) -> (Set a1, Set a)
insertP' :: (Ord a, Ord t) => (t, Set a) -> (Set (t, Set a), Set a) -> (Set (t, Set a), Set a)
main3 :: FilePath -> IO ()
main3P :: FilePath -> IO ()
main4 :: FilePath -> IO ()
main4P :: FilePath -> IO ()
main4SP :: FilePath -> IO ()
varFold :: [String] -> Vect F2 (Lex String)
varFoldP :: [String] -> (Vect F2 (Lex String), Set (Vect F2 (Lex String)))
var' :: (MonomialConstructor m, Algebra k (m [Char]), Show (m [Char]), Ord (m [Char]), Eq k, Num k) => [Char] -> Vect k (m [Char])
var'P :: (MonomialConstructor m, Algebra k (m [Char]), Show (m [Char]), Ord (m [Char]), Eq k, Num k) => [Char] -> (Vect k (m [Char]), Vect k (m [Char]))
disj :: Num a => a -> a -> a
disjP :: (Ord b, Ord k, Num a) => (a, Vect k b) -> (a, Set (Vect k b)) -> (a, Set (Vect k b))
