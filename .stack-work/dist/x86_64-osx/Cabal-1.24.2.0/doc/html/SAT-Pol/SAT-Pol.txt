-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package SAT-Pol
@version 0.1.0.0


-- | This module contains several examples in order to verify the good
--   functioning of the other modules.
module Examples
x1 :: LexPoly F2 String
example :: [LexPoly F2 String]
exampleSet :: Set (LexPoly F2 String)
ej2 :: Vect F2 (Lex String)

module PolAux

-- | clean aims to select the simplest representative of a polynomial in
--   the quotient group F2[x_1,...,x_N]/(x_1+x_1^2,...,x_N+x_N^2). The main
--   idea is to replace every ocurrence of x_i^M with x_i thus we obtain an
--   identical polynomial without exponents greater than 1.
--   
--   In the library HaskellForMaths exists a function that performs the
--   same (%%) so we can check the results. For example: λ&gt; clean
--   (x1^3:: LexPoly F2 String) x1 λ&gt; (x1^3:: LexPoly F2 String) %%
--   [x1^2+x1] x1 λ&gt; clean (x1^3*x2^6+x3^2*x4+x1+1 :: LexPoly F2 String)
--   x1x2+x1+x3x4+1 λ&gt; (x1^3*x2^6+x3^2*x4+x1+1 :: LexPoly F2 String) %%
--   [x1^2+x1,x2^2+x2,x3^2+x3,x4^2+x4] x1x2+x1+x3x4+1
clean :: (Eq k, Num k, Eq (m u), Show u, Ord (m u), Show (m u), Algebra k (m u), MonomialConstructor m) => Vect k (m u) -> Vect k (m u)

-- | deriv calculates the derivative of the polynomial f with respect to
--   the variable v. It's important to note that we use the fact that we
--   are in the quotient group described above. For example:
--   
--   λ&gt; deriv (x1:: LexPoly F2 String) (x1:: LexPoly F2 String) 1 λ&gt;
--   deriv (1+x1+x2+x1*x2:: LexPoly F2 String) (x1:: LexPoly F2 String)
--   x2+1 λ&gt; deriv (x1*x2+x1+x3*x4+1:: LexPoly F2 String) (x1:: LexPoly
--   F2 String) x2+1
deriv :: (Eq k, Eq u, Num k, Ord (m u), Show (m u), Algebra k (m u), MonomialConstructor m) => Vect k (m u) -> Vect k (m u) -> Vect k (m u)


-- | This module aims to provide an efficient tool to solve the SAT
--   problem. Both the algorithm and the implementation have been carried
--   out by the researchers from the department of Computer Science and
--   Artificial Intelligence at the University of Seville.
module Tool

-- | tool decides if the set of formulas that produced the set of
--   polynomials were satisfiables. The function input is a list of
--   polynomials because the transformation from formula to polynomial is
--   handled by ReadingF.hs module.
tool :: (Eq u, Show (m u), Show u, MonomialConstructor m, Algebra k (m u), Ord (m u), Ord k, Num k) => [Vect k (m u)] -> Bool

module ReadingF
main1 :: FilePath -> IO ()
main2 :: FilePath -> IO ()
varFold :: [String] -> Vect F2 (Lex String)
var' :: (MonomialConstructor m, Algebra k (m [Char]), Show (m [Char]), Ord (m [Char]), Eq k, Num k) => [Char] -> Vect k (m [Char])
disj :: Num a => a -> a -> a


-- | This module aims to provide an efficient tool to solve the SAT
--   problem. Both the algorithm and the implementation have been carried
--   out by the researchers from the department of Computer Science and
--   Artificial Intelligence at the University of Seville.
module ToolS

-- | varsSet returns the set of variables which occurs in a polynomial. For
--   example: λ&gt; varsSet (x2*x3+x1) fromList [x1,x2,x3] λ&gt; varsSet
--   (x1) fromList [x1]
varsSet :: (Ord (m v), Num k, Ord k, MonomialConstructor m) => Vect k (m v) -> Set (Vect k (m v))

-- | varsList xs returns the set of variables which occurs in any
--   polynomial of the set xs. For example:
varsList :: (Foldable t, Num k, MonomialConstructor m, Ord (m v), Ord k) => t (Vect k (m v)) -> Set (Vect k (m v))

-- | The function (deltaRule p x y) performs the independence rule
--   described in the paper [?]. It's important to note that p is the
--   variable from wich we derive and the one we would drop. For example:
--   &gt;&gt;&gt; deltaRule (x1:: LexPoly F2 String) (1:: LexPoly F2
--   String) (1:: LexPoly F2 String) 1 &gt;&gt;&gt; deltaRule (x1:: LexPoly
--   F2 String) (1:: LexPoly F2 String) (0:: LexPoly F2 String) 0
--   &gt;&gt;&gt; deltaRule (x1:: LexPoly F2 String) (x1:: LexPoly F2
--   String) (x1:: LexPoly F2 String) 1
deltaRule :: (Eq k, Eq u, Num k, Ord (m u), Algebra k (m u), MonomialConstructor m, Show (m u), Show u) => Vect k (m u) -> Vect k (m u) -> Vect k (m u) -> Vect k (m u)

-- | deltaRule1Step apply deltaRule from p between every polynomial in the
--   first list and store the results in the accumulator (second list). For
--   exaple: λ&gt; deltaRuleList1Step (x1:: LexPoly F2 String) ([x1]::
--   [LexPoly F2 String]) ([1]::[LexPoly F2 String]) [1,1] λ&gt;
--   deltaRuleList1Step (x1:: LexPoly F2 String) ([x1,x1*x2,x1*x3]::
--   [LexPoly F2 String]) ([]::[LexPoly F2 String]) [x3,x2x3,x2,x3,x2,1]
deltaRule1Step :: (Eq k, Eq u, Num k, Ord k, Ord (m u), Algebra k (m u), MonomialConstructor m, Show (m u), Show u) => Vect k (m u) -> Set (Vect k (m u)) -> Set (Vect k (m u)) -> Set (Vect k (m u))
