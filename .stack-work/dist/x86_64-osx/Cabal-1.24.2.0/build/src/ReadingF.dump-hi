
==================== FINAL INTERFACE ====================
2017-07-17 13:16:27.286976 UTC

interface SAT-Pol-0.1.0.0-CfnMeGgalar5P7rViiH2gc:ReadingF 8002
  interface hash: 8776237347ef79ce3b1bdefe82461b9a
  ABI hash: 7470ab0e9abd2721a496ec98603b1d1b
  export-list hash: 3a0ffb5bb8aa08955dbd8f3e29f47110
  orphan hash: 3c7d43334fa801966707ca7eec732540
  flag hash: cc34f77fbcbf6e6d5350ddfb862868c7
  sig of: Nothing
  used TH splices: False
  where
exports:
  ReadingF.disj
  ReadingF.main1
  ReadingF.main2
  ReadingF.main3
  ReadingF.main4
  ReadingF.var'
  ReadingF.varFold
module dependencies: Examples PolAux Tool ToolS
package dependencies: HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.Structures
         HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.CommutativeAlgebra.Polynomial
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz:Data.Set.Internal
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.Structures cbf553a388e500de36f995a8d89172a4
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.TensorProduct c053039aae50bcc7df2c155eefb8e506
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.VectorSpace 6cba24ab7ee9b5f302ba65e0ee801d61
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.CommutativeAlgebra.Polynomial b54042f0d44ec74552e332a486c1ec0b
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Core.Field 75661b1cf3e7c0e1ab0f62f78c950ef8
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Core.Utils 5681b0689a2f6e26ea9c0077f1ee1777
import  -/  PolAux f76a52e75a7d1ed0135ccf56a5f79c80
  exports: b57020b84300bf532d83dddc777afd3c
  clean af1351ab5cca59308ff0417aba8b9c88
import  -/  Tool 44ac5ec346d7f5951e9a95e55818584c
  exports: 9fcd85e70c0c36c42cd255e78a2de8f3
  tool 7c599a5b75432c01aded83b625223c5d
import  -/  ToolS f511e9e242536be025c7de93722553b7
  exports: ed4106494c9ef46613aa6035a62146e5
  toolS f0786fd9630bfa049ee8c0beebe31ecd
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.Environment 08cb808e8e6a7821e6f8cfa76a977431
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz:Data.Set 0a21f3925a0d3a5e69c1f4a8e792bc80
import  -/  containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz:Data.Set.Internal 0eaafc03eaf1eada07e1d85783ded885
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
9e60824f8bbe015b386abcb7539bd1a0
  $s$fAlgebrakLex ::
    Math.Algebras.Structures.Algebra
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Math.Core.Field.F2
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  ReadingF.$s$fAlgebrakLex_$s$fAlgebrakLex_$cunit
                  (Math.CommutativeAlgebra.Polynomial.$fAlgebrakLex_$cmult
                     @ Math.Core.Field.F2
                     @ [GHC.Types.Char]
                     Math.Core.Field.$fEqF2
                     Math.Core.Field.$fNumF2
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Show.$fShow[]_$s$fShow[]1) -}
c7bf809d1a6d7fef027709d44373f408
  $s$fAlgebrakLex_$s$fAlgebrakLex_$cunit ::
    Math.Core.Field.F2
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Arity: 1, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Math.Core.Field.F2) ->
                 Math.Algebras.VectorSpace.smultL
                   @ Math.Core.Field.F2
                   @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   Math.Core.Field.$fEqF2
                   Math.Core.Field.$fNumF2
                   x
                   (GHC.Types.:
                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                         Math.Core.Field.F2)
                      ((Math.CommutativeAlgebra.Polynomial.$fAlgebrakGlex1
                          @ [GHC.Types.Char])
                         `cast`
                       (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                       Math.Core.Field.$fNumF2_$cfromInteger
                         Math.Algebras.VectorSpace.$fApplicativeVect5)
                      (GHC.Types.[]
                         @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                            Math.Core.Field.F2)))
                     `cast`
                   (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                             <Math.Core.Field.F2>_R
                             <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R))) -}
9605f25cb817dfeaa4b6c5117bb2b96e
  $s$fEqLex ::
    GHC.Classes.Eq
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  (Math.CommutativeAlgebra.Polynomial.$fEqLex_$c==
                     @ [GHC.Types.Char]
                     GHC.Classes.$fEq[]_$s$fEq[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fEqLex_$c/=
                     @ [GHC.Types.Char]
                     GHC.Classes.$fEq[]_$s$fEq[]1) -}
d9f25461c749771d70283fd1b1a542eb
  $s$fEqVect1 ::
    GHC.Classes.Eq
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) ReadingF.$s$fEqLex -}
662226a01eb6cbb0cea0dfe2f4780393
  $s$fNumVect2 ::
    [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
      Math.Core.Field.F2)]
  {- Unfolding: (GHC.Types.:
                   @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                      Math.Core.Field.F2)
                   ReadingF.$s$fNumVect3
                   (GHC.Types.[]
                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                         Math.Core.Field.F2))) -}
d26ab7585915fc1327e089931c61fe2d
  $s$fNumVect3 ::
    (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
     Math.Core.Field.F2)
  {- Unfolding: (((Math.CommutativeAlgebra.Polynomial.$fAlgebrakGlex1
                     @ [GHC.Types.Char])
                    `cast`
                  (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                  ReadingF.$s$fNumVect4)) -}
9b1b4c82c6e0deedfd5e7b45aeb57d27
  $s$fNumVect4 :: Math.Core.Field.F2
  {- Unfolding: (case GHC.Classes.modInt# 1# 2# of ww2 { DEFAULT ->
                 (GHC.Types.I# ww2) `cast` (Sym (Math.Core.Field.N:F2[0])) }) -}
90b11218ef46e462410722bd17808e2b
  $s$fNumVect_$s$fOrdLex ::
    GHC.Classes.Ord
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  ReadingF.$s$fEqVect1
                  (Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                     @ [GHC.Types.Char]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  ReadingF.$s$fNumVect_$s$fOrdLex_$c<
                  ReadingF.$s$fNumVect_$s$fOrdLex_$c<=
                  ReadingF.$s$fNumVect_$s$fOrdLex_$c>
                  ReadingF.$s$fNumVect_$s$fOrdLex_$c>=
                  ReadingF.$s$fNumVect_$s$fOrdLex_$cmax
                  ReadingF.$s$fNumVect_$s$fOrdLex_$cmin -}
e1eb102fcb42513eaf718fe9bd536552
  $s$fNumVect_$s$fOrdLex_$c< ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
709446a4460e1975866021b93a7c6f30
  $s$fNumVect_$s$fOrdLex_$c<= ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
dc77cd19f08655aff45404d087bdeb40
  $s$fNumVect_$s$fOrdLex_$c> ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
b42983ce4135762b1fd86033ba192e31
  $s$fNumVect_$s$fOrdLex_$c>= ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
e9a7d6f4f988291029d2ee25b1d75787
  $s$fNumVect_$s$fOrdLex_$cmax ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(U,U)><S(LS),1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
8dbbe55622fee672ec9206069f693bc4
  $s$fNumVect_$s$fOrdLex_$cmin ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(U,U)><S(LS),1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
893451705658bf690f5ba45523823015
  $s$fNumVect_$s$fShowLex ::
    GHC.Show.Show
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  ReadingF.$s$fNumVect_$s$fShowLex_$cshowsPrec
                  (Math.CommutativeAlgebra.Polynomial.$fShowLex_$cshow
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fShowLex_$cshowList
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1) -}
cc20f384e93a1a450f1ba14af4eb2c10
  $s$fNumVect_$s$fShowLex_$cshowsPrec ::
    GHC.Types.Int
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(LS),1*U(A,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.CommutativeAlgebra.Polynomial.$fShowGlex_$cshow1
                         @ [GHC.Types.Char]
                         GHC.Show.$fShow[]_$s$fShow[]1
                         x `cast`
                         (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N)))
                   s) -}
03da8116e44f63e2cbc3d536603301aa
  $sinsert_$sgo5 ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
6e52c0d08aadd2ae8c15e45676fce412
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ReadingF.$trModule2
                   ReadingF.$trModule1) -}
0589bc614c5c3174efc0fb77dd75b66c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ReadingF"#) -}
0149fe17c338a7f8c68919183b18e0b6
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "SAT-Pol-0.1.0.0-CfnMeGgalar5P7rViiH2gc"#) -}
17fc7bd1bb7decf7fe6a5e40f45a518c
  $wvar' ::
    (Math.CommutativeAlgebra.Polynomial.MonomialConstructor m,
     Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]),
     GHC.Classes.Ord (m [GHC.Types.Char]), GHC.Classes.Eq k,
     GHC.Num.Num k) =>
    [GHC.Types.Char]
    -> Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char])
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,1*U(1*C1(U),A)><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ (m :: * -> *)
                   @ k
                   (w :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w1 :: Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]))
                   (w2 :: GHC.Classes.Ord (m [GHC.Types.Char]))
                   (w3 :: GHC.Classes.Eq k)
                   (w4 :: GHC.Num.Num k)
                   (w5 :: [GHC.Types.Char]) ->
                 case w5 of wild {
                   []
                   -> (GHC.Types.:
                         @ (m [GHC.Types.Char], k)
                         (Math.CommutativeAlgebra.Polynomial.mvar
                            @ m
                            w
                            @ [GHC.Types.Char]
                            ReadingF.var'8,
                          GHC.Num.fromInteger
                            @ k
                            w4
                            Math.Algebras.VectorSpace.$fApplicativeVect5)
                         (GHC.Types.[] @ (m [GHC.Types.Char], k)))
                        `cast`
                      (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                <k>_R <m [GHC.Types.Char]>_R))
                   : ds ds1
                   -> case ds of wild1 { GHC.Types.C# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT
                        -> (GHC.Types.:
                              @ (m [GHC.Types.Char], k)
                              (Math.CommutativeAlgebra.Polynomial.mvar
                                 @ m
                                 w
                                 @ [GHC.Types.Char]
                                 (GHC.Types.: @ GHC.Types.Char ReadingF.var'2 wild),
                               GHC.Num.fromInteger
                                 @ k
                                 w4
                                 Math.Algebras.VectorSpace.$fApplicativeVect5)
                              (GHC.Types.[] @ (m [GHC.Types.Char], k)))
                             `cast`
                           (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                     <k>_R <m [GHC.Types.Char]>_R))
                        '-'#
                        -> (Math.Algebras.VectorSpace.addmerge
                              @ k
                              @ (m [GHC.Types.Char])
                              w3
                              w4
                              w2
                              (Math.Algebras.Structures.unit
                                 @ k
                                 @ (m [GHC.Types.Char])
                                 w1
                                 (GHC.Num.fromInteger @ k w4 ReadingF.var'9))
                                `cast`
                              (Math.Algebras.VectorSpace.N:Vect[0] <k>_R <m [GHC.Types.Char]>_R)
                              (GHC.Types.:
                                 @ (m [GHC.Types.Char], k)
                                 (Math.CommutativeAlgebra.Polynomial.mvar
                                    @ m
                                    w
                                    @ [GHC.Types.Char]
                                    (GHC.Types.: @ GHC.Types.Char ReadingF.var'2 ds1),
                                  GHC.Num.fromInteger
                                    @ k
                                    w4
                                    Math.Algebras.VectorSpace.$fApplicativeVect5)
                                 (GHC.Types.[] @ (m [GHC.Types.Char], k))))
                             `cast`
                           (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                     <k>_R <m [GHC.Types.Char]>_R))
                        '0'#
                        -> case ds1 of wild2 {
                             []
                             -> (GHC.Types.[] @ (m [GHC.Types.Char], k))
                                  `cast`
                                (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                          <k>_R <m [GHC.Types.Char]>_R))
                             : ipv ipv1
                             -> (GHC.Types.:
                                   @ (m [GHC.Types.Char], k)
                                   (Math.CommutativeAlgebra.Polynomial.mvar
                                      @ m
                                      w
                                      @ [GHC.Types.Char]
                                      (GHC.Types.: @ GHC.Types.Char ReadingF.var'2 wild),
                                    GHC.Num.fromInteger
                                      @ k
                                      w4
                                      Math.Algebras.VectorSpace.$fApplicativeVect5)
                                   (GHC.Types.[] @ (m [GHC.Types.Char], k)))
                                  `cast`
                                (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                          <k>_R <m [GHC.Types.Char]>_R)) } } } }) -}
044a1ed234fb189df1d2cc64241310dc
  disj :: GHC.Num.Num a => a -> a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(C(C1(U)),A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: (\ @ a ($dNum :: GHC.Num.Num a) (x :: a) (y :: a) ->
                 GHC.Num.+
                   @ a
                   $dNum
                   (GHC.Num.+ @ a $dNum x y)
                   (GHC.Num.* @ a $dNum x y)) -}
162f532bbcc098ad952ffb66019b2582
  disj2 ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.Algebras.TensorProduct.Tensor
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Unfolding: (Math.CommutativeAlgebra.Polynomial.$w$cmult2
                   @ Math.Core.Field.F2
                   @ [GHC.Types.Char]
                   Math.Core.Field.$fEqF2
                   Math.Core.Field.$fNumF2
                   GHC.Classes.$fOrd[]_$s$fOrd[]1) -}
ae752c8a87386f7768ee626c9f9fb5ca
  main1 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main7
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
55ebbd8e24b3cade64c0feca48a34d95
  main10 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (case Tool.$wtool
                           @ GHC.Base.String
                           @ Math.CommutativeAlgebra.Polynomial.Lex
                           @ Math.Core.Field.F2
                           GHC.Classes.$fEq[]_$s$fEq[]1
                           Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorLex
                           ReadingF.$s$fAlgebrakLex
                           ReadingF.$s$fNumVect_$s$fOrdLex
                           Math.Core.Field.$fOrdF2
                           Math.Core.Field.$fNumF2
                           (Data.OldList.nubBy
                              @ (Math.Algebras.VectorSpace.Vect
                                   Math.Core.Field.F2
                                   (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                              ReadingF.main8
                                `cast`
                              (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <Math.Core.Field.F2>_R
                                        <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)
                               ->_R Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                             <Math.Core.Field.F2>_R
                                             <Math.CommutativeAlgebra.Polynomial.Lex
                                                GHC.Base.String>_R)
                               ->_R <GHC.Types.Bool>_R)
                              (ReadingF.main2_go (Data.OldList.lines ipv3))) of wild {
                      GHC.Types.False -> GHC.Show.shows18
                      GHC.Types.True -> GHC.Show.shows17 })
                   GHC.Types.True
                   ipv2 } }) -}
2ef1e7ea5a1f39650223244f93c18956
  main11 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Data.Set.Internal.$fShowSet1
                      (Math.Algebras.VectorSpace.$w$cshowList
                         @ Math.Core.Field.F2
                         @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                         Math.Core.Field.$fShowF2
                         ReadingF.$s$fNumVect_$s$fShowLex
                         (Data.Set.Internal.$fDataSet1
                            @ (Math.Algebras.VectorSpace.Vect
                                 Math.Core.Field.F2
                                 (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                            (GHC.Types.[]
                               @ (Math.Algebras.VectorSpace.Vect
                                    Math.Core.Field.F2
                                    (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)))
                            (ReadingF.main3_go (Data.OldList.lines ipv3)))
                         (GHC.Types.[] @ GHC.Types.Char)))
                   GHC.Types.True
                   ipv2 } }) -}
458d1011cc692cbdd470390d5e084f10
  main12 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (case ToolS.$wtoolS
                           @ GHC.Base.String
                           @ Math.CommutativeAlgebra.Polynomial.Lex
                           @ Math.Core.Field.F2
                           GHC.Classes.$fEq[]_$s$fEq[]1
                           Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorLex
                           ReadingF.$s$fAlgebrakLex
                           ReadingF.$s$fNumVect_$s$fOrdLex
                           Math.Core.Field.$fOrdF2
                           Math.Core.Field.$fNumF2
                           (ReadingF.main4_go (Data.OldList.lines ipv3)) of wild {
                      GHC.Types.False -> GHC.Show.shows18
                      GHC.Types.True -> GHC.Show.shows17 })
                   GHC.Types.True
                   ipv2 } }) -}
e7c37df47cf7a55f3503108070856538
  main1_go ::
    [GHC.Base.String]
    -> [Math.Algebras.VectorSpace.Vect
          Math.Core.Field.F2
          (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)]
  {- Arity: 1, Strictness: <S,1*U> -}
fd5eef4b8e79290d23c49db0c8bd6207
  main2 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main10
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
71516f9260ae5919a603c99e89543b80
  main2_go ::
    [GHC.Base.String]
    -> [Math.Algebras.VectorSpace.Vect
          Math.Core.Field.F2
          (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)]
  {- Arity: 1, Strictness: <S,1*U> -}
cbdc1a1f39c833b1cd272c3d8f7c291e
  main3 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main11
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
358198398d9723cb73ea38bcad9c81dd
  main3_go ::
    [GHC.Base.String]
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 1, Strictness: <S,1*U> -}
749325608af27f68c4ede8a5bf4f50fe
  main4 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main12
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
a7422424ad26490d050065826ea8c881
  main4_go ::
    [GHC.Base.String]
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 1, Strictness: <S,1*U> -}
70b5fa913bdec970ce4f0f6f71e8d079
  main7 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Math.Algebras.VectorSpace.$w$cshowList
                      @ Math.Core.Field.F2
                      @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                      Math.Core.Field.$fShowF2
                      ReadingF.$s$fNumVect_$s$fShowLex
                      (Data.OldList.nubBy
                         @ (Math.Algebras.VectorSpace.Vect
                              Math.Core.Field.F2
                              (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                         ReadingF.main8
                           `cast`
                         (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                   <Math.Core.Field.F2>_R
                                   <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)
                          ->_R Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <Math.Core.Field.F2>_R
                                        <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)
                          ->_R <GHC.Types.Bool>_R)
                         (ReadingF.main1_go (Data.OldList.lines ipv3)))
                      (GHC.Types.[] @ GHC.Types.Char))
                   GHC.Types.True
                   ipv2 } }) -}
7ccd80beacc99e07ef28398c8c80df78
  main8 ::
    [(Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
      Math.Core.Field.F2)]
    -> [(Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
         Math.Core.Field.F2)]
    -> GHC.Types.Bool
  {- Arity: 2,
     Unfolding: (GHC.Classes.$fEq[]_$c==
                   @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
                      Math.Core.Field.F2)
                   ReadingF.main9) -}
146373283972278d01777887aec0bce8
  main9 ::
    GHC.Classes.Eq
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
       Math.Core.Field.F2)
  {- Unfolding: (GHC.Classes.$fEq(,)
                   @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                   @ Math.Core.Field.F2
                   ReadingF.$s$fEqLex
                   Math.Core.Field.$fEqF2) -}
876d856142038dde4d2cacf6c3897353
  var' ::
    (Math.CommutativeAlgebra.Polynomial.MonomialConstructor m,
     Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]),
     GHC.Show.Show (m [GHC.Types.Char]),
     GHC.Classes.Ord (m [GHC.Types.Char]), GHC.Classes.Eq k,
     GHC.Num.Num k) =>
    [GHC.Types.Char]
    -> Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char])
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,1*U(1*C1(U),A)><L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (7, True, True)
                (\ @ (m :: * -> *)
                   @ k
                   (w :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w1 :: Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]))
                   (w2 :: GHC.Show.Show (m [GHC.Types.Char]))
                   (w3 :: GHC.Classes.Ord (m [GHC.Types.Char]))
                   (w4 :: GHC.Classes.Eq k)
                   (w5 :: GHC.Num.Num k)
                   (w6 :: [GHC.Types.Char]) ->
                 ReadingF.$wvar' @ m @ k w w1 w3 w4 w5 w6) -}
8311c511945f4813b69864ca9af7fa3a
  var'1 ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
  {- Unfolding: (case GHC.Classes.modInt# 0# 2# of ww2 { DEFAULT ->
                 case GHC.Classes.modInt# 1# 2# of ww1 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww1 ww2) of wild {
                   GHC.Types.False
                   -> letrec {
                        go :: [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                Math.Core.Field.F2)]
                              -> [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                   Math.Core.Field.F2)]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds2 :: [(Math.CommutativeAlgebra.Polynomial.Lex
                                        [GHC.Types.Char],
                                      Math.Core.Field.F2)]) ->
                          case ds2 of wild1 {
                            []
                            -> GHC.Types.[]
                                 @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                    Math.Core.Field.F2)
                            : y ys
                            -> case y of wild2 { (,) ei xi ->
                               GHC.Types.:
                                 @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                    Math.Core.Field.F2)
                                 (ei,
                                  case xi
                                         `cast`
                                       (Math.Core.Field.N:F2[0]) of wild4 { GHC.Types.I# y1 ->
                                  (GHC.Types.I# (GHC.Prim.*# ww1 y1))
                                    `cast`
                                  (Sym (Math.Core.Field.N:F2[0])) })
                                 (go ys) } }
                      } in
                      (go ReadingF.$s$fNumVect2)
                        `cast`
                      (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                <Math.Core.Field.F2>_R
                                <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R))
                   GHC.Types.True
                   -> (GHC.Types.[]
                         @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                            Math.Core.Field.F2))
                        `cast`
                      (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                <Math.Core.Field.F2>_R
                                <Math.CommutativeAlgebra.Polynomial.Lex
                                   [GHC.Types.Char]>_R)) } } }) -}
9493b185400cef2bb900b7eaa6fb6bd5
  var'2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'x'#) -}
b08e67527b613fc6ffd2b23b8877527e
  var'3 ::
    [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
      Math.Core.Field.F2)]
  {- Unfolding: (GHC.Types.:
                   @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                      Math.Core.Field.F2)
                   ReadingF.var'4
                   (GHC.Types.[]
                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                         Math.Core.Field.F2))) -}
bb681c1667b458dc02222a9c1dd69b36
  var'4 ::
    (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
     Math.Core.Field.F2)
  {- Unfolding: ((ReadingF.var'5
                    `cast`
                  (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                  ReadingF.$s$fNumVect4)) -}
b5bce4857527d58285fec3afcceb3984
  var'5 ::
    Math.CommutativeAlgebra.Polynomial.MonImpl [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (Math.CommutativeAlgebra.Polynomial.M
                   @ [GHC.Types.Char]
                   Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1
                   ReadingF.var'6) -}
2dab4aed72082787d4b9d30fb758dae5
  var'6 :: [([GHC.Types.Char], GHC.Types.Int)]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Char], GHC.Types.Int)
                   ReadingF.var'7
                   (GHC.Types.[] @ ([GHC.Types.Char], GHC.Types.Int))) -}
148456a0689b0da2854e746f8c02f388
  var'7 :: ([GHC.Types.Char], GHC.Types.Int)
  {- HasNoCafRefs,
     Unfolding: ((ReadingF.var'8,
                  Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1)) -}
7da4e394902b8027519d6c8a30e90431
  var'8 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   ReadingF.var'2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
08e0430674fe9a63da241caa12f4a67f
  var'9 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
79876a98be002391296cdfd78719834b
  varFold ::
    [GHC.Base.String]
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) ->
                 case ds of wild {
                   []
                   -> ReadingF.varFold_go
                        (GHC.Types.[] @ GHC.Base.String)
                        (GHC.Types.[]
                           @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                              Math.Core.Field.F2))
                          `cast`
                        (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                  <Math.Core.Field.F2>_R
                                  <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R))
                   : x xs
                   -> case GHC.Base.eqString x ReadingF.varFold2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString x ReadingF.varFold1 of wild2 {
                             GHC.Types.False
                             -> ReadingF.varFold_go
                                  wild
                                  (GHC.Types.[]
                                     @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                        Math.Core.Field.F2))
                                    `cast`
                                  (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                            <Math.Core.Field.F2>_R
                                            <Math.CommutativeAlgebra.Polynomial.Lex
                                               [GHC.Types.Char]>_R))
                             GHC.Types.True -> ReadingF.var'1 }
                        GHC.Types.True -> ReadingF.var'1 } }) -}
c4ebba9b567ff03a28a4ff1dee30f9b5
  varFold1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "p"#) -}
2adeec9ba1656dbe4608b0e0d73651a2
  varFold2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "c"#) -}
4cdb825b46ce85450ce22b3e77b1670f
  varFold_go ::
    [[GHC.Types.Char]]
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
"SPEC/ReadingF $fAlgebrakLex @ F2 @ [Char]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                         [GHC.Types.Char])
                                                            ($dOrd :: GHC.Classes.Ord
                                                                        [GHC.Types.Char])
                                                            ($dNum :: GHC.Num.Num
                                                                        Math.Core.Field.F2)
                                                            ($dEq :: GHC.Classes.Eq
                                                                       Math.Core.Field.F2)
  Math.CommutativeAlgebra.Polynomial.$fAlgebrakLex @ Math.Core.Field.F2
                                                   @ [GHC.Types.Char]
                                                   $dEq
                                                   $dNum
                                                   $dOrd
                                                   $dShow
  = ReadingF.$s$fAlgebrakLex
"SPEC/ReadingF $fAlgebrakLex_$cunit @ F2 @ [Char]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                                [GHC.Types.Char])
                                                                   ($dOrd :: GHC.Classes.Ord
                                                                               [GHC.Types.Char])
                                                                   ($dNum :: GHC.Num.Num
                                                                               Math.Core.Field.F2)
                                                                   ($dEq :: GHC.Classes.Eq
                                                                              Math.Core.Field.F2)
  Math.CommutativeAlgebra.Polynomial.$fAlgebrakLex_$cunit @ Math.Core.Field.F2
                                                          @ [GHC.Types.Char]
                                                          $dEq
                                                          $dNum
                                                          $dOrd
                                                          $dShow
  = ReadingF.$s$fAlgebrakLex_$s$fAlgebrakLex_$cunit
"SPEC/ReadingF $fEqLex @ [Char]" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                            [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fEqLex @ [GHC.Types.Char] $dEq
  = ReadingF.$s$fEqLex
"SPEC/ReadingF $fOrdLex @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                              [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex @ [GHC.Types.Char]
                                              $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex
"SPEC/ReadingF $fOrdLex_$c< @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                  [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex_$c< @ [GHC.Types.Char]
                                                  $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex_$c<
"SPEC/ReadingF $fOrdLex_$c<= @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                   [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex_$c<= @ [GHC.Types.Char]
                                                   $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex_$c<=
"SPEC/ReadingF $fOrdLex_$c> @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                  [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex_$c> @ [GHC.Types.Char]
                                                  $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex_$c>
"SPEC/ReadingF $fOrdLex_$c>= @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                   [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex_$c>= @ [GHC.Types.Char]
                                                   $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex_$c>=
"SPEC/ReadingF $fOrdLex_$cmax @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                    [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex_$cmax @ [GHC.Types.Char]
                                                    $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex_$cmax
"SPEC/ReadingF $fOrdLex_$cmin @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                    [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex_$cmin @ [GHC.Types.Char]
                                                    $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex_$cmin
"SPEC/ReadingF $fShowLex @ [Char]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fShowLex @ [GHC.Types.Char]
                                               $dShow
  = ReadingF.$s$fNumVect_$s$fShowLex
"SPEC/ReadingF $fShowLex_$cshowsPrec @ [Char]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                            [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fShowLex_$cshowsPrec @ [GHC.Types.Char]
                                                           $dShow
  = ReadingF.$s$fNumVect_$s$fShowLex_$cshowsPrec
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

