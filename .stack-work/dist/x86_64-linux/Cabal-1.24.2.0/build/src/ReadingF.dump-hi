
==================== FINAL INTERFACE ====================
2017-07-18 16:20:00.147211 UTC

interface SAT-Pol-0.1.0.0-CfnMeGgalar5P7rViiH2gc:ReadingF 8002
  interface hash: bb476bad2311f7ae8883106f1e84b233
  ABI hash: 5a0bbd60442ceae7cfc09a5f5e8de297
  export-list hash: 5ea9e6406694e9a1001c11c9f5a5fe11
  orphan hash: 6ae35f4e1a61de76eaa4667f6ab05079
  flag hash: 72fd5e76f20e8265f8631677f08f813e
  sig of: Nothing
  used TH splices: False
  where
exports:
  ReadingF.cleanP
  ReadingF.disj
  ReadingF.disjP
  ReadingF.insertP
  ReadingF.main1
  ReadingF.main2
  ReadingF.main3
  ReadingF.main3P
  ReadingF.main4
  ReadingF.main4P
  ReadingF.var'
  ReadingF.var'P
  ReadingF.varFold
  ReadingF.varFoldP
module dependencies: Examples PolAux Tool ToolS
package dependencies: HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.Structures
         HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.CommutativeAlgebra.Polynomial
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz:Data.Set.Internal
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.Structures cbf553a388e500de36f995a8d89172a4
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.TensorProduct c053039aae50bcc7df2c155eefb8e506
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.VectorSpace 6cba24ab7ee9b5f302ba65e0ee801d61
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.CommutativeAlgebra.Polynomial c7dfc0a11b8634b439ae5817bdafa9d0
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Core.Field 75661b1cf3e7c0e1ab0f62f78c950ef8
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Core.Utils e8d4344d39cc226f5c5792a794aef4e4
import  -/  PolAux f76a52e75a7d1ed0135ccf56a5f79c80
  exports: b57020b84300bf532d83dddc777afd3c
  clean af1351ab5cca59308ff0417aba8b9c88
import  -/  Tool a1f0f2a01166b32f697cb035761adfd5
  exports: 1338835f5d130848e8e6f38e8c759d1e
  tool 76b8b1ecf2b06a3521e11b178ce43423
import  -/  ToolS 38fc35e0b7cde97e51ef9ae9622ad91a
  exports: 4ee23660eb555fdd0baa25de627c8030
  toolS baad9b2fcd9c65151f06c3a57686b673
  toolSP' 9d75de18c8a3f983f48fef14514456d4
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.Environment 08cb808e8e6a7821e6f8cfa76a977431
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz:Data.Set 0a21f3925a0d3a5e69c1f4a8e792bc80
import  -/  containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz:Data.Set.Internal c7bd399b31e0ba0fc7a7a66d48f33dbc
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
9e60824f8bbe015b386abcb7539bd1a0
  $s$fAlgebrakLex ::
    Math.Algebras.Structures.Algebra
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Math.Core.Field.F2
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  ReadingF.$s$fAlgebrakLex_$s$fAlgebrakLex_$cunit
                  (Math.CommutativeAlgebra.Polynomial.$fAlgebrakLex_$cmult
                     @ Math.Core.Field.F2
                     @ [GHC.Types.Char]
                     Math.Core.Field.$fEqF2
                     Math.Core.Field.$fNumF2
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Show.$fShow[]_$s$fShow[]1) -}
c7bf809d1a6d7fef027709d44373f408
  $s$fAlgebrakLex_$s$fAlgebrakLex_$cunit ::
    Math.Core.Field.F2
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Arity: 1, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Math.Core.Field.F2) ->
                 Math.Algebras.VectorSpace.smultL
                   @ Math.Core.Field.F2
                   @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   Math.Core.Field.$fEqF2
                   Math.Core.Field.$fNumF2
                   x
                   (GHC.Types.:
                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                         Math.Core.Field.F2)
                      ((Math.CommutativeAlgebra.Polynomial.$fAlgebrakGlex1
                          @ [GHC.Types.Char])
                         `cast`
                       (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                       Math.Core.Field.$fNumF2_$cfromInteger
                         Math.Algebras.VectorSpace.$fApplicativeVect5)
                      (GHC.Types.[]
                         @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                            Math.Core.Field.F2)))
                     `cast`
                   (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                             <Math.Core.Field.F2>_R
                             <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R))) -}
338376e0533b9f5620effad49f00b975
  $s$fEqLex ::
    GHC.Classes.Eq
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  (Math.CommutativeAlgebra.Polynomial.$fEqLex_$c==
                     @ [GHC.Types.Char]
                     ReadingF.$s$fEqLex_$dEq)
                  (Math.CommutativeAlgebra.Polynomial.$fEqLex_$c/=
                     @ [GHC.Types.Char]
                     ReadingF.$s$fEqLex_$dEq) -}
1dae075502fb7ab8567c03f677ee7e62
  $s$fEqLex_$dEq :: GHC.Classes.Eq [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]1 -}
3c4e283a6a101c1738d4543b2569e497
  $s$fEqVect1 ::
    GHC.Classes.Eq
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) ReadingF.$s$fEqLex -}
8b93aa3060d33f1f34e974f576fffdce
  $s$fMonLex ::
    Math.Algebras.Structures.Mon
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  (Math.CommutativeAlgebra.Polynomial.$fMonLex_$cmunit
                     @ [GHC.Types.Char]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fMonLex_$cmmult
                     @ [GHC.Types.Char]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1) -}
348b839394ce83830ac225444b4d2c5b
  $s$fMonomialLex ::
    Math.CommutativeAlgebra.Polynomial.Monomial
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  ReadingF.$s$fEqVect1
                  ReadingF.$s$fMonomialLex1
                  ReadingF.$s$fMonomialLex_$s$fMonomialLex_$cp3Monomial
                  (Math.CommutativeAlgebra.Polynomial.$fMonomialLex_$cmdivides
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fMonomialLex_$cmdiv
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fMonomialLex_$cmgcd
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fMonomialLex_$cmlcm
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fMonomialLex_$cmcoprime
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fMonomialLex_$cmdeg
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]1) -}
155110a47a15b27ec913cecc28270c58
  $s$fMonomialLex1 ::
    GHC.Show.Show
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ReadingF.$s$fMonomialLex_$s$fShowLex -}
773dca59b1a5053a864fee135d466dc9
  $s$fMonomialLex2 ::
    GHC.Types.Int
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(LS),1*U(A,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (s :: GHC.Base.String) ->
                 case x `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww { Math.CommutativeAlgebra.Polynomial.M ww1 ww2 ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.CommutativeAlgebra.Polynomial.$w$cshow1
                         @ [GHC.Types.Char]
                         GHC.Show.$fShow[]_$s$fShow[]1
                         ww2))
                   s }) -}
f135024002ba117b3a92b6cf3cd40649
  $s$fMonomialLex_$s$fMonomialLex_$cp3Monomial ::
    Math.Algebras.Structures.Mon
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) ReadingF.$s$fMonLex -}
0269cceff086bdd82ecc9fd2ad394805
  $s$fMonomialLex_$s$fShowLex ::
    GHC.Show.Show
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  ReadingF.$s$fMonomialLex2
                  (Math.CommutativeAlgebra.Polynomial.$fShowLex_$cshow
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1)
                  (Math.CommutativeAlgebra.Polynomial.$fShowLex_$cshowList
                     @ [GHC.Types.Char]
                     GHC.Show.$fShow[]_$s$fShow[]1) -}
bf8d9998e8efeb452e0195265dbc0baa
  $s$fNumVect3 ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(U,U)><S(LS),1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case x `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww { Math.CommutativeAlgebra.Polynomial.M ww1 ww2 ->
                 case y `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww3 { Math.CommutativeAlgebra.Polynomial.M ww4 ww5 ->
                 case Math.CommutativeAlgebra.Polynomial.$w$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        ww2
                        ww5 of wild {
                   DEFAULT
                   -> ww
                        `cast`
                      (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N)
                   GHC.Types.GT
                   -> ww3
                        `cast`
                      (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N) } } }) -}
165cbe073e04c36d92671dc8a43648b3
  $s$fNumVect4 ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(U,U)><S(LS),1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case x `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww { Math.CommutativeAlgebra.Polynomial.M ww1 ww2 ->
                 case y `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww3 { Math.CommutativeAlgebra.Polynomial.M ww4 ww5 ->
                 case Math.CommutativeAlgebra.Polynomial.$w$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        ww2
                        ww5 of wild {
                   DEFAULT
                   -> ww3
                        `cast`
                      (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N)
                   GHC.Types.GT
                   -> ww
                        `cast`
                      (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N) } } }) -}
b15806a45e310bd7f0b9c62b729fb7f4
  $s$fNumVect5 ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case x `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww { Math.CommutativeAlgebra.Polynomial.M ww1 ww2 ->
                 case y `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww3 { Math.CommutativeAlgebra.Polynomial.M ww4 ww5 ->
                 case Math.CommutativeAlgebra.Polynomial.$w$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        ww2
                        ww5 of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
755e9571320a2aeae97e11fc99155ee9
  $s$fNumVect6 ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case x `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww { Math.CommutativeAlgebra.Polynomial.M ww1 ww2 ->
                 case y `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww3 { Math.CommutativeAlgebra.Polynomial.M ww4 ww5 ->
                 case Math.CommutativeAlgebra.Polynomial.$w$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        ww2
                        ww5 of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } }) -}
60bb7ea13993bebd3cdff23b3c145aeb
  $s$fNumVect7 ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case x `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww { Math.CommutativeAlgebra.Polynomial.M ww1 ww2 ->
                 case y `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww3 { Math.CommutativeAlgebra.Polynomial.M ww4 ww5 ->
                 case Math.CommutativeAlgebra.Polynomial.$w$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        ww2
                        ww5 of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } }) -}
5424aee9675e9b31d9b7804e66b01a87
  $s$fNumVect8 ::
    Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                   (y :: Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) ->
                 case x `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww { Math.CommutativeAlgebra.Polynomial.M ww1 ww2 ->
                 case y `cast`
                      (Math.CommutativeAlgebra.Polynomial.N:Lex[0] <[GHC.Types.Char]>_N) of ww3 { Math.CommutativeAlgebra.Polynomial.M ww4 ww5 ->
                 case Math.CommutativeAlgebra.Polynomial.$w$ccompare
                        @ [GHC.Types.Char]
                        GHC.Classes.$fOrd[]_$s$fOrd[]1
                        ww2
                        ww5 of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } }) -}
10ca00d367101f7c62b4b2f1e172157a
  $s$fNumVect_$s$fOrdLex ::
    GHC.Classes.Ord
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                  ReadingF.$s$fEqVect1
                  (Math.CommutativeAlgebra.Polynomial.$fOrdLex_$ccompare
                     @ [GHC.Types.Char]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  ReadingF.$s$fNumVect8
                  ReadingF.$s$fNumVect7
                  ReadingF.$s$fNumVect6
                  ReadingF.$s$fNumVect5
                  ReadingF.$s$fNumVect4
                  ReadingF.$s$fNumVect3 -}
282a219f46ec0533990d44c75485fa8c
  $s$fShow(,)_$s$fShowVect ::
    GHC.Show.Show
      (Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Math.Algebras.VectorSpace.Vect
                       Math.Core.Field.F2
                       (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                  ReadingF.$s$fShow(,)_$s$fShowVect_$cshowsPrec
                  (Math.Algebras.VectorSpace.$fShowVect_$cshow
                     @ Math.Core.Field.F2
                     @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                     Math.Core.Field.$fShowF2
                     Math.Core.Field.$fEqF2
                     Math.Core.Field.$fNumF2
                     ReadingF.$s$fMonomialLex1)
                  (Math.Algebras.VectorSpace.$fShowVect_$cshowList
                     @ Math.Core.Field.F2
                     @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                     Math.Core.Field.$fShowF2
                     Math.Core.Field.$fEqF2
                     Math.Core.Field.$fNumF2
                     ReadingF.$s$fMonomialLex1) -}
b069d2588ddd59556b90be9db66dbea8
  $s$fShow(,)_$s$fShowVect_$cshowsPrec ::
    GHC.Types.Int
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Math.Algebras.VectorSpace.Vect
                           Math.Core.Field.F2
                           (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b1
                      (c :: GHC.Types.Char -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b1
                      c
                      n
                      (Math.Algebras.VectorSpace.$fShowVect_$cshow
                         @ Math.Core.Field.F2
                         @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                         Math.Core.Field.$fShowF2
                         Math.Core.Field.$fEqF2
                         Math.Core.Field.$fNumF2
                         ReadingF.$s$fMonomialLex1
                         x))
                   s) -}
778ed5ca8a45866d44585d0e04f12522
  $s$wsplitS ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
    -> (# Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)),
          Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)) #)
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [NEVER] -}
eec0c29e6f0bf56174cfc122afd09eef
  $sinsert ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x0 :: Math.Algebras.VectorSpace.Vect
                            Math.Core.Field.F2
                            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                   (eta :: Data.Set.Internal.Set
                             (Math.Algebras.VectorSpace.Vect
                                Math.Core.Field.F2
                                (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))) ->
                 ReadingF.$sinsert_$sgo5 x0 x0 eta) -}
bb0790720cff137d0b1742c044476f4e
  $sinsertR_$sgo5 ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
e19388781f361335237feab54e0ab68f
  $sinsert_$sgo5 ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
3b49a4a0a23d1f9783c483c50f7de2cb
  $sunion ::
    Data.Set.Internal.Set
      (Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [NEVER] -}
6e52c0d08aadd2ae8c15e45676fce412
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ReadingF.$trModule2
                   ReadingF.$trModule1) -}
0589bc614c5c3174efc0fb77dd75b66c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ReadingF"#) -}
0149fe17c338a7f8c68919183b18e0b6
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "SAT-Pol-0.1.0.0-CfnMeGgalar5P7rViiH2gc"#) -}
9ac29e485d8018c66476c4fd4f2f04a6
  $w$sdisjP ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))
    -> (# Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]),
          Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])) #)
  {- Arity: 4, Strictness: <L,U><S,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: Math.Algebras.VectorSpace.Vect
                            Math.Core.Field.F2
                            (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))
                   (ww1 :: Math.Algebras.VectorSpace.Vect
                             Math.Core.Field.F2
                             (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))
                   (ww2 :: Math.Algebras.VectorSpace.Vect
                             Math.Core.Field.F2
                             (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))
                   (ww3 :: Data.Set.Internal.Set
                             (Math.Algebras.VectorSpace.Vect
                                Math.Core.Field.F2
                                (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                           Math.Core.Field.F2)
                        ReadingF.disjP1
                        ww1
                          `cast`
                        (Math.Algebras.VectorSpace.N:Vect[0]
                             <Math.Core.Field.F2>_R
                             <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R)
                        (GHC.Types.[]
                           @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                              Math.Core.Field.F2)) of wild {
                   GHC.Types.False
                   -> (# (Math.Algebras.VectorSpace.addmerge
                            @ Math.Core.Field.F2
                            @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                            Math.Core.Field.$fEqF2
                            Math.Core.Field.$fNumF2
                            ReadingF.$s$fNumVect_$s$fOrdLex
                            (Math.Algebras.VectorSpace.addmerge
                               @ Math.Core.Field.F2
                               @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                               Math.Core.Field.$fEqF2
                               Math.Core.Field.$fNumF2
                               ReadingF.$s$fNumVect_$s$fOrdLex
                               ww
                                 `cast`
                               (Math.Algebras.VectorSpace.N:Vect[0]
                                    <Math.Core.Field.F2>_R
                                    <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)
                               ww2
                                 `cast`
                               (Math.Algebras.VectorSpace.N:Vect[0]
                                    <Math.Core.Field.F2>_R
                                    <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R))
                            (ReadingF.disj2
                               (Math.Algebras.TensorProduct.reify1
                                  @ Math.Core.Field.F2
                                  @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                                  @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                                  Math.Core.Field.$fNumF2
                                  ww
                                  ww2)
                                 `cast`
                               (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                         <Math.Core.Field.F2>_R
                                         <(Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
                                           Math.CommutativeAlgebra.Polynomial.Lex
                                             GHC.Base.String)>_R)))
                              `cast`
                            (Math.Algebras.VectorSpace.N:Vect[0]
                                 <Math.Core.Field.F2>_R
                                 <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R))
                           `cast`
                         (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                   <Math.Core.Field.F2>_R
                                   <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)),
                         ReadingF.$sinsert ww1 ww3 #)
                   GHC.Types.True -> (# ww2, ww3 #) }) -}
a1e5a857b861f2ebd30b8e898c346cfc
  $w$svar'P ::
    [GHC.Types.Char]
    -> (# Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]),
          Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Char]) ->
                 let {
                   $wfail :: GHC.Prim.Void#
                             -> (# Math.Algebras.VectorSpace.Vect
                                     Math.Core.Field.F2
                                     (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]),
                                   Math.Algebras.VectorSpace.Vect
                                     Math.Core.Field.F2
                                     (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]) #)
                     {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                   = \ (void :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       x :: [GHC.Types.Char]
                       = GHC.Types.: @ GHC.Types.Char ReadingF.var'5 w
                     } in
                     let {
                       x1 :: ([GHC.Types.Char], GHC.Types.Int) {- Strictness: m -}
                       = (x,
                          Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1)
                     } in
                     let {
                       x2 :: [([GHC.Types.Char], GHC.Types.Int)]
                       = GHC.Types.:
                           @ ([GHC.Types.Char], GHC.Types.Int)
                           x1
                           (GHC.Types.[] @ ([GHC.Types.Char], GHC.Types.Int))
                     } in
                     let {
                       x3 :: Math.CommutativeAlgebra.Polynomial.MonImpl [GHC.Types.Char]
                         {- Strictness: m -}
                       = Math.CommutativeAlgebra.Polynomial.M
                           @ [GHC.Types.Char]
                           Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1
                           x2
                     } in
                     let {
                       x4 :: (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                              Math.Core.Field.F2)
                         {- Strictness: m -}
                       = (x3
                            `cast`
                          (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                          ReadingF.var'4)
                     } in
                     let {
                       x5 :: [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                               Math.Core.Field.F2)]
                       = GHC.Types.:
                           @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                              Math.Core.Field.F2)
                           x4
                           (GHC.Types.[]
                              @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                 Math.Core.Field.F2))
                     } in
                     (# x5
                          `cast`
                        (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                  <Math.Core.Field.F2>_R
                                  <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R)),
                        x5
                          `cast`
                        (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                  <Math.Core.Field.F2>_R
                                  <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R)) #)
                 } in
                 case w of wild {
                   [] -> $wfail GHC.Prim.void#
                   : ds ds1
                   -> case ds of wild1 { GHC.Types.C# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT -> $wfail GHC.Prim.void#
                        '-'#
                        -> let {
                             x :: [GHC.Types.Char]
                             = GHC.Types.: @ GHC.Types.Char ReadingF.var'5 ds1
                           } in
                           let {
                             x1 :: ([GHC.Types.Char], GHC.Types.Int) {- Strictness: m -}
                             = (x,
                                Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1)
                           } in
                           let {
                             x2 :: [([GHC.Types.Char], GHC.Types.Int)]
                             = GHC.Types.:
                                 @ ([GHC.Types.Char], GHC.Types.Int)
                                 x1
                                 (GHC.Types.[] @ ([GHC.Types.Char], GHC.Types.Int))
                           } in
                           let {
                             x3 :: Math.CommutativeAlgebra.Polynomial.MonImpl [GHC.Types.Char]
                               {- Strictness: m -}
                             = Math.CommutativeAlgebra.Polynomial.M
                                 @ [GHC.Types.Char]
                                 Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1
                                 x2
                           } in
                           let {
                             x4 :: (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                    Math.Core.Field.F2)
                               {- Strictness: m -}
                             = (x3
                                  `cast`
                                (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                                ReadingF.var'4)
                           } in
                           let {
                             x5 :: [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                     Math.Core.Field.F2)]
                             = GHC.Types.:
                                 @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                    Math.Core.Field.F2)
                                 x4
                                 (GHC.Types.[]
                                    @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                       Math.Core.Field.F2))
                           } in
                           (# (Math.Algebras.VectorSpace.addmerge
                                 @ Math.Core.Field.F2
                                 @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
                                 Math.Core.Field.$fEqF2
                                 Math.Core.Field.$fNumF2
                                 ReadingF.$s$fNumVect_$s$fOrdLex
                                 ReadingF.var'1
                                   `cast`
                                 (Math.Algebras.VectorSpace.N:Vect[0]
                                      <Math.Core.Field.F2>_R
                                      <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R)
                                 x5)
                                `cast`
                              (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <Math.Core.Field.F2>_R
                                        <Math.CommutativeAlgebra.Polynomial.Lex
                                           [GHC.Types.Char]>_R)),
                              x5
                                `cast`
                              (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <Math.Core.Field.F2>_R
                                        <Math.CommutativeAlgebra.Polynomial.Lex
                                           [GHC.Types.Char]>_R)) #)
                        '0'#
                        -> case ds1 of wild2 {
                             []
                             -> (# (GHC.Types.[]
                                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                         Math.Core.Field.F2))
                                     `cast`
                                   (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                             <Math.Core.Field.F2>_R
                                             <Math.CommutativeAlgebra.Polynomial.Lex
                                                [GHC.Types.Char]>_R)),
                                   (GHC.Types.[]
                                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                         Math.Core.Field.F2))
                                     `cast`
                                   (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                             <Math.Core.Field.F2>_R
                                             <Math.CommutativeAlgebra.Polynomial.Lex
                                                [GHC.Types.Char]>_R)) #)
                             : ipv ipv1 -> $wfail GHC.Prim.void# } } } }) -}
687b578e26237427d7e1fa0b60d02449
  $wgo ::
    [GHC.Base.String]
    -> (# Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)),
          Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)) #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
4aa3e52cea4069b7341e4a9afef85ba8
  $wgo1 ::
    [GHC.Base.String]
    -> (# Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)),
          Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)) #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
e957b100cb11b57c753ba97cdf2dccc2
  $wgo2 ::
    [[GHC.Types.Char]]
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))
    -> (# Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]),
          Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])) #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0] -}
bc126102ae3201ce20179bfd956c692a
  $wvar' ::
    (Math.CommutativeAlgebra.Polynomial.MonomialConstructor m,
     Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]),
     GHC.Classes.Ord (m [GHC.Types.Char]), GHC.Classes.Eq k,
     GHC.Num.Num k) =>
    [GHC.Types.Char]
    -> Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char])
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,1*U(1*C1(U),A)><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ (m :: * -> *)
                   @ k
                   (w :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w1 :: Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]))
                   (w2 :: GHC.Classes.Ord (m [GHC.Types.Char]))
                   (w3 :: GHC.Classes.Eq k)
                   (w4 :: GHC.Num.Num k)
                   (w5 :: [GHC.Types.Char]) ->
                 case w5 of wild {
                   []
                   -> (GHC.Types.:
                         @ (m [GHC.Types.Char], k)
                         (Math.CommutativeAlgebra.Polynomial.mvar
                            @ m
                            w
                            @ [GHC.Types.Char]
                            ReadingF.var'11,
                          GHC.Num.fromInteger
                            @ k
                            w4
                            Math.Algebras.VectorSpace.$fApplicativeVect5)
                         (GHC.Types.[] @ (m [GHC.Types.Char], k)))
                        `cast`
                      (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                <k>_R <m [GHC.Types.Char]>_R))
                   : ds ds1
                   -> case ds of wild1 { GHC.Types.C# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT
                        -> (GHC.Types.:
                              @ (m [GHC.Types.Char], k)
                              (Math.CommutativeAlgebra.Polynomial.mvar
                                 @ m
                                 w
                                 @ [GHC.Types.Char]
                                 (GHC.Types.: @ GHC.Types.Char ReadingF.var'5 wild),
                               GHC.Num.fromInteger
                                 @ k
                                 w4
                                 Math.Algebras.VectorSpace.$fApplicativeVect5)
                              (GHC.Types.[] @ (m [GHC.Types.Char], k)))
                             `cast`
                           (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                     <k>_R <m [GHC.Types.Char]>_R))
                        '-'#
                        -> (Math.Algebras.VectorSpace.addmerge
                              @ k
                              @ (m [GHC.Types.Char])
                              w3
                              w4
                              w2
                              (Math.Algebras.Structures.unit
                                 @ k
                                 @ (m [GHC.Types.Char])
                                 w1
                                 (GHC.Num.fromInteger @ k w4 ReadingF.var'12))
                                `cast`
                              (Math.Algebras.VectorSpace.N:Vect[0] <k>_R <m [GHC.Types.Char]>_R)
                              (GHC.Types.:
                                 @ (m [GHC.Types.Char], k)
                                 (Math.CommutativeAlgebra.Polynomial.mvar
                                    @ m
                                    w
                                    @ [GHC.Types.Char]
                                    (GHC.Types.: @ GHC.Types.Char ReadingF.var'5 ds1),
                                  GHC.Num.fromInteger
                                    @ k
                                    w4
                                    Math.Algebras.VectorSpace.$fApplicativeVect5)
                                 (GHC.Types.[] @ (m [GHC.Types.Char], k))))
                             `cast`
                           (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                     <k>_R <m [GHC.Types.Char]>_R))
                        '0'#
                        -> case ds1 of wild2 {
                             []
                             -> (GHC.Types.[] @ (m [GHC.Types.Char], k))
                                  `cast`
                                (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                          <k>_R <m [GHC.Types.Char]>_R))
                             : ipv ipv1
                             -> (GHC.Types.:
                                   @ (m [GHC.Types.Char], k)
                                   (Math.CommutativeAlgebra.Polynomial.mvar
                                      @ m
                                      w
                                      @ [GHC.Types.Char]
                                      (GHC.Types.: @ GHC.Types.Char ReadingF.var'5 wild),
                                    GHC.Num.fromInteger
                                      @ k
                                      w4
                                      Math.Algebras.VectorSpace.$fApplicativeVect5)
                                   (GHC.Types.[] @ (m [GHC.Types.Char], k)))
                                  `cast`
                                (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                          <k>_R <m [GHC.Types.Char]>_R)) } } } }) -}
4ff0f714d4e4b53c8aa27c5af7804349
  $wvar'P ::
    (Math.CommutativeAlgebra.Polynomial.MonomialConstructor m,
     Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]),
     GHC.Classes.Ord (m [GHC.Types.Char]), GHC.Classes.Eq k,
     GHC.Num.Num k) =>
    [GHC.Types.Char]
    -> (# Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char]),
          Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char]) #)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,1*U(1*C1(U),A)><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><S,U>,
     Inline: [0],
     Unfolding: (\ @ (m :: * -> *)
                   @ k
                   (w :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w1 :: Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]))
                   (w2 :: GHC.Classes.Ord (m [GHC.Types.Char]))
                   (w3 :: GHC.Classes.Eq k)
                   (w4 :: GHC.Num.Num k)
                   (w5 :: [GHC.Types.Char]) ->
                 let {
                   $wfail :: GHC.Prim.Void#
                             -> (# Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char]),
                                   Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char]) #)
                     {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                   = \ (void :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       x :: m [GHC.Types.Char]
                       = Math.CommutativeAlgebra.Polynomial.mvar
                           @ m
                           w
                           @ [GHC.Types.Char]
                           (GHC.Types.: @ GHC.Types.Char ReadingF.var'5 w5)
                     } in
                     let {
                       x1 :: k
                       = GHC.Num.fromInteger
                           @ k
                           w4
                           Math.Algebras.VectorSpace.$fApplicativeVect5
                     } in
                     let {
                       x2 :: (m [GHC.Types.Char], k) {- Strictness: m -} = (x, x1)
                     } in
                     let {
                       x3 :: [(m [GHC.Types.Char], k)]
                       = GHC.Types.:
                           @ (m [GHC.Types.Char], k)
                           x2
                           (GHC.Types.[] @ (m [GHC.Types.Char], k))
                     } in
                     (# x3
                          `cast`
                        (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                  <k>_R <m [GHC.Types.Char]>_R)),
                        x3
                          `cast`
                        (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                  <k>_R <m [GHC.Types.Char]>_R)) #)
                 } in
                 case w5 of wild {
                   [] -> $wfail GHC.Prim.void#
                   : ds ds1
                   -> case ds of wild1 { GHC.Types.C# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT -> $wfail GHC.Prim.void#
                        '-'#
                        -> let {
                             x :: m [GHC.Types.Char]
                             = Math.CommutativeAlgebra.Polynomial.mvar
                                 @ m
                                 w
                                 @ [GHC.Types.Char]
                                 (GHC.Types.: @ GHC.Types.Char ReadingF.var'5 ds1)
                           } in
                           let {
                             x1 :: k
                             = GHC.Num.fromInteger
                                 @ k
                                 w4
                                 Math.Algebras.VectorSpace.$fApplicativeVect5
                           } in
                           let {
                             x2 :: (m [GHC.Types.Char], k) {- Strictness: m -} = (x, x1)
                           } in
                           let {
                             x3 :: [(m [GHC.Types.Char], k)]
                             = GHC.Types.:
                                 @ (m [GHC.Types.Char], k)
                                 x2
                                 (GHC.Types.[] @ (m [GHC.Types.Char], k))
                           } in
                           (# (Math.Algebras.VectorSpace.addmerge
                                 @ k
                                 @ (m [GHC.Types.Char])
                                 w3
                                 w4
                                 w2
                                 (Math.Algebras.Structures.unit
                                    @ k
                                    @ (m [GHC.Types.Char])
                                    w1
                                    (GHC.Num.fromInteger @ k w4 ReadingF.var'12))
                                   `cast`
                                 (Math.Algebras.VectorSpace.N:Vect[0] <k>_R <m [GHC.Types.Char]>_R)
                                 x3)
                                `cast`
                              (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <k>_R <m [GHC.Types.Char]>_R)),
                              x3
                                `cast`
                              (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <k>_R <m [GHC.Types.Char]>_R)) #)
                        '0'#
                        -> case ds1 of wild2 {
                             []
                             -> (# (GHC.Types.[] @ (m [GHC.Types.Char], k))
                                     `cast`
                                   (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                             <k>_R <m [GHC.Types.Char]>_R)),
                                   (GHC.Types.[] @ (m [GHC.Types.Char], k))
                                     `cast`
                                   (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                             <k>_R <m [GHC.Types.Char]>_R)) #)
                             : ipv ipv1 -> $wfail GHC.Prim.void# } } } }) -}
89e62801fa9eab7e5ea58e38d90421c3
  $wvarFoldP ::
    [GHC.Base.String]
    -> (# Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String),
          Data.Set.Internal.Set
            (Math.Algebras.VectorSpace.Vect
               Math.Core.Field.F2
               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)) #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Base.String]) ->
                 case w of wild {
                   []
                   -> ReadingF.$wgo2
                        (GHC.Types.[] @ GHC.Base.String)
                        (GHC.Types.[]
                           @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                              Math.Core.Field.F2))
                          `cast`
                        (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                  <Math.Core.Field.F2>_R
                                  <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R))
                        (Data.Set.Internal.Tip
                           @ (Math.Algebras.VectorSpace.Vect
                                Math.Core.Field.F2
                                (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])))
                   : x xs
                   -> case GHC.Base.eqString x ReadingF.varFold2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString x ReadingF.varFold1 of wild2 {
                             GHC.Types.False
                             -> ReadingF.$wgo2
                                  wild
                                  (GHC.Types.[]
                                     @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                        Math.Core.Field.F2))
                                    `cast`
                                  (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                            <Math.Core.Field.F2>_R
                                            <Math.CommutativeAlgebra.Polynomial.Lex
                                               [GHC.Types.Char]>_R))
                                  (Data.Set.Internal.Tip
                                     @ (Math.Algebras.VectorSpace.Vect
                                          Math.Core.Field.F2
                                          (Math.CommutativeAlgebra.Polynomial.Lex
                                             [GHC.Types.Char])))
                             GHC.Types.True
                             -> (# ReadingF.var'1,
                                   Data.Set.Internal.Tip
                                     @ (Math.Algebras.VectorSpace.Vect
                                          Math.Core.Field.F2
                                          (Math.CommutativeAlgebra.Polynomial.Lex
                                             GHC.Base.String)) #) }
                        GHC.Types.True
                        -> (# ReadingF.var'1,
                              Data.Set.Internal.Tip
                                @ (Math.Algebras.VectorSpace.Vect
                                     Math.Core.Field.F2
                                     (Math.CommutativeAlgebra.Polynomial.Lex
                                        GHC.Base.String)) #) } }) -}
789c6cb9d7e565d9d5dcb3ce660ba92a
  cleanP ::
    (Math.CommutativeAlgebra.Polynomial.MonomialConstructor m,
     Math.Algebras.Structures.Algebra k (m u), GHC.Show.Show (m u),
     GHC.Show.Show u, GHC.Classes.Ord (m u), GHC.Classes.Eq k,
     GHC.Num.Num k) =>
    (Math.Algebras.VectorSpace.Vect k (m u), t)
    -> (Math.Algebras.VectorSpace.Vect k (m u), t)
  {- Arity: 8,
     Strictness: <L,U(C(U),C(U))><L,U(C(U),C(U))><L,A><L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (8, True, False)
                (\ @ u
                   @ (m :: * -> *)
                   @ k
                   @ t
                   ($dMonomialConstructor :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor
                                               m)
                   ($dAlgebra :: Math.Algebras.Structures.Algebra k (m u))
                   ($dShow :: GHC.Show.Show (m u))
                   ($dShow1 :: GHC.Show.Show u)
                   ($dOrd :: GHC.Classes.Ord (m u))
                   ($dEq :: GHC.Classes.Eq k)
                   ($dNum :: GHC.Num.Num k)
                   (eta :: (Math.Algebras.VectorSpace.Vect k (m u), t)) ->
                 case eta of wild { (,) a b ->
                 (PolAux.$wclean
                    @ k
                    @ m
                    @ u
                    $dEq
                    $dNum
                    $dOrd
                    $dAlgebra
                    $dMonomialConstructor
                    a,
                  b) }) -}
044a1ed234fb189df1d2cc64241310dc
  disj :: GHC.Num.Num a => a -> a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(C(C1(U)),A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: (\ @ a ($dNum :: GHC.Num.Num a) (x :: a) (y :: a) ->
                 GHC.Num.+
                   @ a
                   $dNum
                   (GHC.Num.+ @ a $dNum x y)
                   (GHC.Num.* @ a $dNum x y)) -}
162f532bbcc098ad952ffb66019b2582
  disj2 ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.Algebras.TensorProduct.Tensor
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]))
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Unfolding: (Math.CommutativeAlgebra.Polynomial.$w$cmult2
                   @ Math.Core.Field.F2
                   @ [GHC.Types.Char]
                   Math.Core.Field.$fEqF2
                   Math.Core.Field.$fNumF2
                   GHC.Classes.$fOrd[]_$s$fOrd[]1) -}
e3accf4b28763ef5a7082c6d605ca111
  disjP ::
    (GHC.Classes.Ord b, GHC.Classes.Ord k, GHC.Num.Num a) =>
    (a, Math.Algebras.VectorSpace.Vect k b)
    -> (a, Data.Set.Internal.Set (Math.Algebras.VectorSpace.Vect k b))
    -> (a, Data.Set.Internal.Set (Math.Algebras.VectorSpace.Vect k b))
  {- Arity: 3,
     Strictness: <L,U(U(U,U),C(C1(U)),A,A,A,A,A,A)><L,U(U(U,U),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),C(C1(U)),A,A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ b
                   @ k
                   @ a
                   ($dOrd :: GHC.Classes.Ord b)
                   ($dOrd1 :: GHC.Classes.Ord k)
                   ($dNum :: GHC.Num.Num a) ->
                 let {
                   $dOrd2 :: GHC.Classes.Ord (Math.Algebras.VectorSpace.Vect k b)
                   = Math.Algebras.VectorSpace.$fOrdVect @ k @ b $dOrd1 $dOrd
                 } in
                 let {
                   $dEq :: GHC.Classes.Eq b = GHC.Classes.$p1Ord @ b $dOrd
                 } in
                 let {
                   $dEq1 :: GHC.Classes.Eq k = GHC.Classes.$p1Ord @ k $dOrd1
                 } in
                 let {
                   lvl36 :: GHC.Classes.Eq (b, k)
                   = GHC.Classes.$fEq(,) @ b @ k $dEq $dEq1
                 } in
                 \ (ds :: (a, Math.Algebras.VectorSpace.Vect k b))
                   (ds1 :: (a,
                            Data.Set.Internal.Set (Math.Algebras.VectorSpace.Vect k b))) ->
                 case ds of wild { (,) x v ->
                 case ds1 of wild1 { (,) y vs ->
                 case GHC.Classes.$fEq[]_$c==
                        @ (b, k)
                        lvl36
                        v `cast` (Math.Algebras.VectorSpace.N:Vect[0] <k>_R <b>_R)
                        (GHC.Types.[] @ (b, k)) of wild2 {
                   GHC.Types.False
                   -> (ReadingF.disj @ a $dNum x y,
                       Data.Set.Internal.insert
                         @ (Math.Algebras.VectorSpace.Vect k b)
                         $dOrd2
                         v
                         vs)
                   GHC.Types.True -> wild1 } } }) -}
2cb9f94c1f599e540cc5be6923efa8b5
  disjP1 ::
    GHC.Classes.Eq
      (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
       Math.Core.Field.F2)
  {- Unfolding: (GHC.Classes.$fEq(,)
                   @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                   @ Math.Core.Field.F2
                   ReadingF.$s$fEqLex
                   Math.Core.Field.$fEqF2) -}
3d7cb6077411b62e7c97a7b8831cad20
  insertP ::
    (GHC.Classes.Ord a, GHC.Classes.Ord a1) =>
    (a1, Data.Set.Internal.Set a)
    -> (Data.Set.Internal.Set a1, Data.Set.Internal.Set a)
    -> (Data.Set.Internal.Set a1, Data.Set.Internal.Set a)
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(1*U,1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ a1
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dOrd1 :: GHC.Classes.Ord a1)
                   (ds :: (a1, Data.Set.Internal.Set a))
                   (ds1 :: (Data.Set.Internal.Set a1, Data.Set.Internal.Set a)) ->
                 case ds of wild { (,) a2 b ->
                 case ds1 of wild1 { (,) acc vs ->
                 (Data.Set.Internal.insert @ a1 $dOrd1 a2 acc,
                  Data.Set.Internal.union @ a $dOrd vs b) } }) -}
d4958cd238c0e16ffeadf0d7b2b590d7
  main1 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main7
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
67e7f88eb72cc8854f738d0319142b47
  main10 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Data.Set.Internal.$fShowSet1
                      (Math.Algebras.VectorSpace.$w$cshowList
                         @ Math.Core.Field.F2
                         @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                         Math.Core.Field.$fShowF2
                         ReadingF.$s$fMonomialLex_$s$fShowLex
                         (Data.Set.Internal.$fDataSet1
                            @ (Math.Algebras.VectorSpace.Vect
                                 Math.Core.Field.F2
                                 (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                            (GHC.Types.[]
                               @ (Math.Algebras.VectorSpace.Vect
                                    Math.Core.Field.F2
                                    (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)))
                            (ReadingF.main3_go (Data.OldList.lines ipv3)))
                         (GHC.Types.[] @ GHC.Types.Char)))
                   GHC.Types.True
                   ipv2 } }) -}
11c58fb186b04b6df8028bc1a60fedd9
  main11 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (case ToolS.$wtoolS
                           @ GHC.Base.String
                           @ Math.CommutativeAlgebra.Polynomial.Lex
                           @ Math.Core.Field.F2
                           GHC.Classes.$fEq[]_$s$fEq[]1
                           Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorLex
                           ReadingF.$s$fAlgebrakLex
                           ReadingF.$s$fNumVect_$s$fOrdLex
                           ReadingF.$s$fMonomialLex
                           Math.Core.Field.$fOrdF2
                           Math.Core.Field.$fNumF2
                           (ReadingF.main4_go (Data.OldList.lines ipv3)) of wild {
                      GHC.Types.False -> GHC.Show.shows18
                      GHC.Types.True -> GHC.Show.shows17 })
                   GHC.Types.True
                   ipv2 } }) -}
e7c37df47cf7a55f3503108070856538
  main1_go ::
    [GHC.Base.String]
    -> [Math.Algebras.VectorSpace.Vect
          Math.Core.Field.F2
          (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)]
  {- Arity: 1, Strictness: <S,1*U> -}
a60dc355678b5486737160b9753ed2b4
  main2 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main9
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
71516f9260ae5919a603c99e89543b80
  main2_go ::
    [GHC.Base.String]
    -> [Math.Algebras.VectorSpace.Vect
          Math.Core.Field.F2
          (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)]
  {- Arity: 1, Strictness: <S,1*U> -}
c881cf406c76cc7d10d1d0bee75a3022
  main3 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main10
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
d69f565fba66d7f9a633f14d9f11a3d5
  main3P :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main3P1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
a47cb48551b9ccfd2050609599502b3c
  main3P1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (case ReadingF.$wgo
                           (Data.OldList.lines ipv3) of ww { (#,#) ww1 ww2 ->
                    GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows7
                      (GHC.Base.++
                         @ GHC.Types.Char
                         Data.Set.Internal.$fShowSet1
                         (Math.Algebras.VectorSpace.$w$cshowList
                            @ Math.Core.Field.F2
                            @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                            Math.Core.Field.$fShowF2
                            ReadingF.$s$fMonomialLex_$s$fShowLex
                            (Data.Set.Internal.$fDataSet1
                               @ (Math.Algebras.VectorSpace.Vect
                                    Math.Core.Field.F2
                                    (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                               (GHC.Types.[]
                                  @ (Math.Algebras.VectorSpace.Vect
                                       Math.Core.Field.F2
                                       (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)))
                               ww1)
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows5
                               (GHC.Show.$fShow(,)_$sgo
                                  ReadingF.main3P2
                                  (Data.Set.Internal.$w$cshowsPrec
                                     @ (Math.Algebras.VectorSpace.Vect
                                          Math.Core.Field.F2
                                          (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                                     ReadingF.$s$fShow(,)_$s$fShowVect
                                     0#
                                     ww2)
                                  (GHC.Types.[] @ GHC.Show.ShowS))))) })
                   GHC.Types.True
                   ipv2 } }) -}
9011716aed4d39d6258f01db059f101d
  main3P2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4b71f43ac27133ca830989a77f2708d8
  main3_go ::
    [GHC.Base.String]
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 1, Strictness: <S,1*U> -}
9f9f32fbc0710fc93cd703711e2d7208
  main4 :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main11
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
424b3aba3cee77142125c5238540004e
  main4P :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                ReadingF.main4P1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
fe52d7f4d30af997a7b16db668a7ae58
  main4P1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (case ReadingF.$wgo1
                           (Data.OldList.lines ipv3) of ww { (#,#) ww1 ww2 ->
                    case ToolS.$wtoolAux
                           @ Math.Core.Field.F2
                           @ GHC.Base.String
                           @ Math.CommutativeAlgebra.Polynomial.Lex
                           Math.Core.Field.$fOrdF2
                           GHC.Classes.$fEq[]_$s$fEq[]1
                           Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorLex
                           ReadingF.$s$fAlgebrakLex
                           ReadingF.$s$fNumVect_$s$fOrdLex
                           ReadingF.$s$fMonomialLex
                           Math.Core.Field.$fNumF2
                           ww2
                           ww1 of wild {
                      GHC.Types.False -> GHC.Show.shows18
                      GHC.Types.True -> GHC.Show.shows17 } })
                   GHC.Types.True
                   ipv2 } }) -}
8f69d5b4b55aedb2a1f81c802202c385
  main4_go ::
    [GHC.Base.String]
    -> Data.Set.Internal.Set
         (Math.Algebras.VectorSpace.Vect
            Math.Core.Field.F2
            (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
  {- Arity: 1, Strictness: <S,1*U> -}
f03c297cf2f71f552a1fc5542f0c4ea4
  main7 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Math.Algebras.VectorSpace.$w$cshowList
                      @ Math.Core.Field.F2
                      @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                      Math.Core.Field.$fShowF2
                      ReadingF.$s$fMonomialLex_$s$fShowLex
                      (Data.OldList.nubBy
                         @ (Math.Algebras.VectorSpace.Vect
                              Math.Core.Field.F2
                              (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                         ReadingF.main8
                           `cast`
                         (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                   <Math.Core.Field.F2>_R
                                   <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)
                          ->_R Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <Math.Core.Field.F2>_R
                                        <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)
                          ->_R <GHC.Types.Bool>_R)
                         (ReadingF.main1_go (Data.OldList.lines ipv3)))
                      (GHC.Types.[] @ GHC.Types.Char))
                   GHC.Types.True
                   ipv2 } }) -}
9cd40c14d944771503c523cfbb899998
  main8 ::
    [(Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
      Math.Core.Field.F2)]
    -> [(Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
         Math.Core.Field.F2)]
    -> GHC.Types.Bool
  {- Arity: 2,
     Unfolding: (GHC.Classes.$fEq[]_$c==
                   @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String,
                      Math.Core.Field.F2)
                   ReadingF.disjP1) -}
ca6cbc0bf67ee187c988976480f2baa3
  main9 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        f
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (case Tool.$wtool
                           @ GHC.Base.String
                           @ Math.CommutativeAlgebra.Polynomial.Lex
                           @ Math.Core.Field.F2
                           GHC.Classes.$fEq[]_$s$fEq[]1
                           Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorLex
                           ReadingF.$s$fAlgebrakLex
                           ReadingF.$s$fNumVect_$s$fOrdLex
                           Math.Core.Field.$fOrdF2
                           Math.Core.Field.$fNumF2
                           (Data.OldList.nubBy
                              @ (Math.Algebras.VectorSpace.Vect
                                   Math.Core.Field.F2
                                   (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                              ReadingF.main8
                                `cast`
                              (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                        <Math.Core.Field.F2>_R
                                        <Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String>_R)
                               ->_R Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                             <Math.Core.Field.F2>_R
                                             <Math.CommutativeAlgebra.Polynomial.Lex
                                                GHC.Base.String>_R)
                               ->_R <GHC.Types.Bool>_R)
                              (ReadingF.main2_go (Data.OldList.lines ipv3))) of wild {
                      GHC.Types.False -> GHC.Show.shows18
                      GHC.Types.True -> GHC.Show.shows17 })
                   GHC.Types.True
                   ipv2 } }) -}
fe3b68917fe7dac4c6747d6c2c5189f5
  var' ::
    (Math.CommutativeAlgebra.Polynomial.MonomialConstructor m,
     Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]),
     GHC.Show.Show (m [GHC.Types.Char]),
     GHC.Classes.Ord (m [GHC.Types.Char]), GHC.Classes.Eq k,
     GHC.Num.Num k) =>
    [GHC.Types.Char]
    -> Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char])
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,1*U(1*C1(U),A)><L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (7, True, True)
                (\ @ (m :: * -> *)
                   @ k
                   (w :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w1 :: Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]))
                   (w2 :: GHC.Show.Show (m [GHC.Types.Char]))
                   (w3 :: GHC.Classes.Ord (m [GHC.Types.Char]))
                   (w4 :: GHC.Classes.Eq k)
                   (w5 :: GHC.Num.Num k)
                   (w6 :: [GHC.Types.Char]) ->
                 ReadingF.$wvar' @ m @ k w w1 w3 w4 w5 w6) -}
6148d0bf93bb8cd4c661d81612c1c064
  var'1 ::
    Math.Algebras.VectorSpace.Vect
      Math.Core.Field.F2
      (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Unfolding: (case GHC.Classes.modInt# 0# 2# of ww2 { DEFAULT ->
                 case GHC.Classes.modInt# 1# 2# of ww1 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww1 ww2) of wild {
                   GHC.Types.False
                   -> letrec {
                        go :: [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                Math.Core.Field.F2)]
                              -> [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                   Math.Core.Field.F2)]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds2 :: [(Math.CommutativeAlgebra.Polynomial.Lex
                                        [GHC.Types.Char],
                                      Math.Core.Field.F2)]) ->
                          case ds2 of wild1 {
                            []
                            -> GHC.Types.[]
                                 @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                    Math.Core.Field.F2)
                            : y ys
                            -> case y of wild2 { (,) ei xi ->
                               GHC.Types.:
                                 @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                    Math.Core.Field.F2)
                                 (ei,
                                  case xi
                                         `cast`
                                       (Math.Core.Field.N:F2[0]) of wild4 { GHC.Types.I# y1 ->
                                  (GHC.Types.I# (GHC.Prim.*# ww1 y1))
                                    `cast`
                                  (Sym (Math.Core.Field.N:F2[0])) })
                                 (go ys) } }
                      } in
                      (go ReadingF.var'2)
                        `cast`
                      (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                <Math.Core.Field.F2>_R
                                <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R))
                   GHC.Types.True
                   -> (GHC.Types.[]
                         @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                            Math.Core.Field.F2))
                        `cast`
                      (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                <Math.Core.Field.F2>_R
                                <Math.CommutativeAlgebra.Polynomial.Lex
                                   [GHC.Types.Char]>_R)) } } }) -}
e29a6ededa7d410890c55e4033fc987a
  var'10 :: ([GHC.Types.Char], GHC.Types.Int)
  {- HasNoCafRefs,
     Unfolding: ((ReadingF.var'11,
                  Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1)) -}
bb705e79361605029e95646d4cc04589
  var'11 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   ReadingF.var'5
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b835157fd177b4dda473e861e1fcc32d
  var'12 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
e883acb33ad219ff5e27b75fdab03b72
  var'2 ::
    [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
      Math.Core.Field.F2)]
  {- Unfolding: (GHC.Types.:
                   @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                      Math.Core.Field.F2)
                   ReadingF.var'3
                   (GHC.Types.[]
                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                         Math.Core.Field.F2))) -}
b7c6a2fd400aa21737cec206961a9716
  var'3 ::
    (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
     Math.Core.Field.F2)
  {- Unfolding: (((Math.CommutativeAlgebra.Polynomial.$fAlgebrakGlex1
                     @ [GHC.Types.Char])
                    `cast`
                  (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                  ReadingF.var'4)) -}
44cb69bd8585535d00ad46ab397c7124
  var'4 :: Math.Core.Field.F2
  {- Unfolding: (case GHC.Classes.modInt# 1# 2# of ww2 { DEFAULT ->
                 (GHC.Types.I# ww2) `cast` (Sym (Math.Core.Field.N:F2[0])) }) -}
672e4e9bd2a6567020d057d8d7ca9f91
  var'5 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'x'#) -}
a8805df6a31836f1ad4e33394b15b4de
  var'6 ::
    [(Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
      Math.Core.Field.F2)]
  {- Unfolding: (GHC.Types.:
                   @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                      Math.Core.Field.F2)
                   ReadingF.var'7
                   (GHC.Types.[]
                      @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                         Math.Core.Field.F2))) -}
cb9e9a03eff1fb6fa5e077129f53c1d6
  var'7 ::
    (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
     Math.Core.Field.F2)
  {- Unfolding: ((ReadingF.var'8
                    `cast`
                  (Sym (Math.CommutativeAlgebra.Polynomial.N:Lex[0]) <[GHC.Types.Char]>_N),
                  ReadingF.var'4)) -}
f7623649c423d84c3c503c2e22cad125
  var'8 ::
    Math.CommutativeAlgebra.Polynomial.MonImpl [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (Math.CommutativeAlgebra.Polynomial.M
                   @ [GHC.Types.Char]
                   Math.CommutativeAlgebra.Polynomial.$fMonomialConstructorGlex1
                   ReadingF.var'9) -}
3e9019b46e781087f6c9ebbb1a37449f
  var'9 :: [([GHC.Types.Char], GHC.Types.Int)]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Char], GHC.Types.Int)
                   ReadingF.var'10
                   (GHC.Types.[] @ ([GHC.Types.Char], GHC.Types.Int))) -}
84c89960606e8e286f03cf0112bca6b0
  var'P ::
    (Math.CommutativeAlgebra.Polynomial.MonomialConstructor m,
     Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]),
     GHC.Show.Show (m [GHC.Types.Char]),
     GHC.Classes.Ord (m [GHC.Types.Char]), GHC.Classes.Eq k,
     GHC.Num.Num k) =>
    [GHC.Types.Char]
    -> (Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char]),
        Math.Algebras.VectorSpace.Vect k (m [GHC.Types.Char]))
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(U),A)><L,1*U(1*C1(U),A)><L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><S,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (7, True, False)
                (\ @ (m :: * -> *)
                   @ k
                   (w :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w1 :: Math.Algebras.Structures.Algebra k (m [GHC.Types.Char]))
                   (w2 :: GHC.Show.Show (m [GHC.Types.Char]))
                   (w3 :: GHC.Classes.Ord (m [GHC.Types.Char]))
                   (w4 :: GHC.Classes.Eq k)
                   (w5 :: GHC.Num.Num k)
                   (w6 :: [GHC.Types.Char]) ->
                 case ReadingF.$wvar'P
                        @ m
                        @ k
                        w
                        w1
                        w3
                        w4
                        w5
                        w6 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
3d4d130dfa52bef6453096d0773d4ad2
  varFold ::
    [GHC.Base.String]
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) ->
                 case ds of wild {
                   []
                   -> ReadingF.varFold_go
                        (GHC.Types.[] @ GHC.Base.String)
                        (GHC.Types.[]
                           @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                              Math.Core.Field.F2))
                          `cast`
                        (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                  <Math.Core.Field.F2>_R
                                  <Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char]>_R))
                   : x xs
                   -> case GHC.Base.eqString x ReadingF.varFold2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString x ReadingF.varFold1 of wild2 {
                             GHC.Types.False
                             -> ReadingF.varFold_go
                                  wild
                                  (GHC.Types.[]
                                     @ (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char],
                                        Math.Core.Field.F2))
                                    `cast`
                                  (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                            <Math.Core.Field.F2>_R
                                            <Math.CommutativeAlgebra.Polynomial.Lex
                                               [GHC.Types.Char]>_R))
                             GHC.Types.True -> ReadingF.var'1 }
                        GHC.Types.True -> ReadingF.var'1 } }) -}
c4ebba9b567ff03a28a4ff1dee30f9b5
  varFold1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "p"#) -}
2adeec9ba1656dbe4608b0e0d73651a2
  varFold2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "c"#) -}
9e601a755f1bdec1b46a673c5770fb5e
  varFoldP ::
    [GHC.Base.String]
    -> (Math.Algebras.VectorSpace.Vect
          Math.Core.Field.F2
          (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String),
        Data.Set.Internal.Set
          (Math.Algebras.VectorSpace.Vect
             Math.Core.Field.F2
             (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)))
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Base.String]) ->
                 case ReadingF.$wvarFoldP w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
4cdb825b46ce85450ce22b3e77b1670f
  varFold_go ::
    [[GHC.Types.Char]]
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
    -> Math.Algebras.VectorSpace.Vect
         Math.Core.Field.F2
         (Math.CommutativeAlgebra.Polynomial.Lex [GHC.Types.Char])
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
"SPEC/ReadingF $fAlgebrakLex @ F2 @ [Char]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                         [GHC.Types.Char])
                                                            ($dOrd :: GHC.Classes.Ord
                                                                        [GHC.Types.Char])
                                                            ($dNum :: GHC.Num.Num
                                                                        Math.Core.Field.F2)
                                                            ($dEq :: GHC.Classes.Eq
                                                                       Math.Core.Field.F2)
  Math.CommutativeAlgebra.Polynomial.$fAlgebrakLex @ Math.Core.Field.F2
                                                   @ [GHC.Types.Char]
                                                   $dEq
                                                   $dNum
                                                   $dOrd
                                                   $dShow
  = ReadingF.$s$fAlgebrakLex
"SPEC/ReadingF $fAlgebrakLex_$cunit @ F2 @ [Char]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                                [GHC.Types.Char])
                                                                   ($dOrd :: GHC.Classes.Ord
                                                                               [GHC.Types.Char])
                                                                   ($dNum :: GHC.Num.Num
                                                                               Math.Core.Field.F2)
                                                                   ($dEq :: GHC.Classes.Eq
                                                                              Math.Core.Field.F2)
  Math.CommutativeAlgebra.Polynomial.$fAlgebrakLex_$cunit @ Math.Core.Field.F2
                                                          @ [GHC.Types.Char]
                                                          $dEq
                                                          $dNum
                                                          $dOrd
                                                          $dShow
  = ReadingF.$s$fAlgebrakLex_$s$fAlgebrakLex_$cunit
"SPEC/ReadingF $fEqLex @ [Char]" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                            [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fEqLex @ [GHC.Types.Char] $dEq
  = ReadingF.$s$fEqLex
"SPEC/ReadingF $fMonLex @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                              [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fMonLex @ [GHC.Types.Char]
                                              $dOrd
  = ReadingF.$s$fMonLex
"SPEC/ReadingF $fMonomialLex @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                   [GHC.Types.Char])
                                                       ($dShow :: GHC.Show.Show [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fMonomialLex @ [GHC.Types.Char]
                                                   $dShow
                                                   $dOrd
  = ReadingF.$s$fMonomialLex
"SPEC/ReadingF $fMonomialLex_$cp3Monomial @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                                [GHC.Types.Char])
                                                                    ($dShow :: GHC.Show.Show
                                                                                 [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fMonomialLex_$cp3Monomial @ [GHC.Types.Char]
                                                                $dShow
                                                                $dOrd
  = ReadingF.$s$fMonomialLex_$s$fMonomialLex_$cp3Monomial
"SPEC/ReadingF $fOrdLex @ [Char]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                              [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fOrdLex @ [GHC.Types.Char]
                                              $dOrd
  = ReadingF.$s$fNumVect_$s$fOrdLex
"SPEC/ReadingF $fShowLex @ [Char]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                [GHC.Types.Char])
  Math.CommutativeAlgebra.Polynomial.$fShowLex @ [GHC.Types.Char]
                                               $dShow
  = ReadingF.$s$fMonomialLex_$s$fShowLex
"SPEC/ReadingF $fShowVect @ F2 @ (Lex String)" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                             (Math.CommutativeAlgebra.Polynomial.Lex
                                                                                GHC.Base.String))
                                                               ($dNum :: GHC.Num.Num
                                                                           Math.Core.Field.F2)
                                                               ($dEq :: GHC.Classes.Eq
                                                                          Math.Core.Field.F2)
                                                               ($dShow :: GHC.Show.Show
                                                                            Math.Core.Field.F2)
  Math.Algebras.VectorSpace.$fShowVect @ Math.Core.Field.F2
                                       @ (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String)
                                       $dShow
                                       $dEq
                                       $dNum
                                       $dShow1
  = ReadingF.$s$fShow(,)_$s$fShowVect
"SPEC/ReadingF $fShowVect_$cshowsPrec @ F2 @ (Lex String)" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                                         (Math.CommutativeAlgebra.Polynomial.Lex
                                                                                            GHC.Base.String))
                                                                           ($dNum :: GHC.Num.Num
                                                                                       Math.Core.Field.F2)
                                                                           ($dEq :: GHC.Classes.Eq
                                                                                      Math.Core.Field.F2)
                                                                           ($dShow :: GHC.Show.Show
                                                                                        Math.Core.Field.F2)
  Math.Algebras.VectorSpace.$fShowVect_$cshowsPrec @ Math.Core.Field.F2
                                                   @ (Math.CommutativeAlgebra.Polynomial.Lex
                                                        GHC.Base.String)
                                                   $dShow
                                                   $dEq
                                                   $dNum
                                                   $dShow1
  = ReadingF.$s$fShow(,)_$s$fShowVect_$cshowsPrec
"SPEC/ReadingF $wsplitS @ (Vect F2 (Lex String))" [0] forall (w :: GHC.Classes.Ord
                                                                     (Math.Algebras.VectorSpace.Vect
                                                                        Math.Core.Field.F2
                                                                        (Math.CommutativeAlgebra.Polynomial.Lex
                                                                           GHC.Base.String)))
  Data.Set.Internal.$wsplitS @ (Math.Algebras.VectorSpace.Vect
                                  Math.Core.Field.F2
                                  (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                             w
  = ReadingF.$s$wsplitS
"SPEC/ReadingF insert @ (Vect F2 (Lex String))" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                            (Math.Algebras.VectorSpace.Vect
                                                                               Math.Core.Field.F2
                                                                               (Math.CommutativeAlgebra.Polynomial.Lex
                                                                                  GHC.Base.String)))
  Data.Set.Internal.insert @ (Math.Algebras.VectorSpace.Vect
                                Math.Core.Field.F2
                                (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                           $dOrd
  = ReadingF.$sinsert
"SPEC/ReadingF union @ (Vect F2 (Lex String))" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                           (Math.Algebras.VectorSpace.Vect
                                                                              Math.Core.Field.F2
                                                                              (Math.CommutativeAlgebra.Polynomial.Lex
                                                                                 GHC.Base.String)))
  Data.Set.Internal.union @ (Math.Algebras.VectorSpace.Vect
                               Math.Core.Field.F2
                               (Math.CommutativeAlgebra.Polynomial.Lex GHC.Base.String))
                          $dOrd
  = ReadingF.$sunion
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

