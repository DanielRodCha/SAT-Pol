
==================== FINAL INTERFACE ====================
2017-07-18 16:19:59.225037 UTC

interface SAT-Pol-0.1.0.0-CfnMeGgalar5P7rViiH2gc:PolAux 8002
  interface hash: cf6c772105821049a652a48db7e32eeb
  ABI hash: f76a52e75a7d1ed0135ccf56a5f79c80
  export-list hash: b57020b84300bf532d83dddc777afd3c
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 72fd5e76f20e8265f8631677f08f813e
  sig of: Nothing
  used TH splices: False
  where
exports:
  PolAux.clean
  PolAux.deriv
module dependencies: Examples
package dependencies: HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.Structures
         HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.CommutativeAlgebra.Polynomial
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.10.2@containers-0.5.10.2-BsNvjXoQS1iGZ9xbXaQ0Mz:Data.Set.Internal
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.Structures cbf553a388e500de36f995a8d89172a4
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.TensorProduct c053039aae50bcc7df2c155eefb8e506
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Algebras.VectorSpace 6cba24ab7ee9b5f302ba65e0ee801d61
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.CommutativeAlgebra.Polynomial c7dfc0a11b8634b439ae5817bdafa9d0
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Core.Field 75661b1cf3e7c0e1ab0f62f78c950ef8
import  -/  HaskellForMaths-0.4.8@HaskellForMaths-0.4.8-8QcC8dcD7HF183G9RK8zU9:Math.Core.Utils e8d4344d39cc226f5c5792a794aef4e4
import  -/  Examples f96905f064774e5fcb5305995f909891
  exports: 57158dab1915eb85d42e3823d14af835
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
517af6adce4ea57f4f746d4ebe3ae700
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   PolAux.$trModule2
                   PolAux.$trModule1) -}
3a3c0ffb4540061f6c7eea5fc7d3d444
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "PolAux"#) -}
cd72e2cf9cb23f033d2691c40ff6ebe6
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "SAT-Pol-0.1.0.0-CfnMeGgalar5P7rViiH2gc"#) -}
d1d4e03885a1541ba9e13828ca22e0a1
  $wclean ::
    (GHC.Classes.Eq k, GHC.Num.Num k, GHC.Classes.Ord (m u),
     Math.Algebras.Structures.Algebra k (m u),
     Math.CommutativeAlgebra.Polynomial.MonomialConstructor m) =>
    Math.Algebras.VectorSpace.Vect k (m u)
    -> Math.Algebras.VectorSpace.Vect k (m u)
  {- Arity: 6,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U(C(U),C(U))><L,U(C(U),C(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ k
                   @ (m :: * -> *)
                   @ u
                   (w :: GHC.Classes.Eq k)
                   (w1 :: GHC.Num.Num k)
                   (w2 :: GHC.Classes.Ord (m u))
                   (w3 :: Math.Algebras.Structures.Algebra k (m u))
                   (w4 :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w5 :: Math.Algebras.VectorSpace.Vect k (m u)) ->
                 let {
                   lvl1 :: Math.Algebras.VectorSpace.Vect k (m u)
                   = Math.Algebras.Structures.unit
                       @ k
                       @ (m u)
                       w3
                       (GHC.Num.fromInteger @ k w1 PolAux.clean1)
                 } in
                 let {
                   lvl2 :: k
                   = GHC.Num.fromInteger
                       @ k
                       w1
                       Math.Algebras.VectorSpace.$fApplicativeVect5
                 } in
                 letrec {
                   go :: [(u, GHC.Types.Int)]
                         -> Math.Algebras.VectorSpace.Vect k (m u)
                         -> Math.Algebras.VectorSpace.Vect k (m u)
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [(u, GHC.Types.Int)])
                       (eta :: Math.Algebras.VectorSpace.Vect k (m u)) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case y of wild1 { (,) x i ->
                          go
                            ys
                            (Math.Algebras.Structures.mult
                               @ k
                               @ (m u)
                               w3
                               (Math.Algebras.TensorProduct.reify1
                                  @ k
                                  @ (m u)
                                  @ (m u)
                                  w1
                                  eta
                                  (GHC.Types.:
                                     @ (m u, k)
                                     (Math.CommutativeAlgebra.Polynomial.mvar @ m w4 @ u x, lvl2)
                                     (GHC.Types.[] @ (m u, k)))
                                    `cast`
                                  (Sym (Math.Algebras.VectorSpace.N:Vect[0] <k>_R <m u>_R)))
                                 `cast`
                               (Sym (Math.Algebras.VectorSpace.N:Vect[0]
                                         <k>_R <(m u, m u)>_R))) } }
                 } in
                 Math.Algebras.VectorSpace.nf
                   @ k
                   @ (m u)
                   w
                   w1
                   w2
                   (Math.Algebras.VectorSpace.$fApplicativeVect4
                      @ k
                      w1
                      @ (m u)
                      @ (m u)
                      w5
                      (\ (m1 :: m u) ->
                       go
                         (Math.CommutativeAlgebra.Polynomial.mindices @ m w4 @ u m1)
                         lvl1))
                     `cast`
                   (Sym (Math.Algebras.VectorSpace.N:Vect[0] <k>_R <m u>_R))) -}
a5f084d723767357f820006a303e1191
  $wderiv ::
    (GHC.Classes.Eq k, GHC.Classes.Eq u, GHC.Num.Num k,
     GHC.Classes.Ord (m u), Math.Algebras.Structures.Algebra k (m u),
     Math.CommutativeAlgebra.Polynomial.MonomialConstructor m) =>
    Math.Algebras.VectorSpace.Vect k (m u)
    -> Math.Algebras.VectorSpace.Vect k (m u)
    -> Math.Algebras.VectorSpace.Vect k (m u)
  {- Arity: 8,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),C(C1(U)))><L,U(C(C1(U)),A,C(C1(U)),C(U),A,A,C(U))><L,U(1*U,C(C1(U)),A,A,A,A,A,A)><L,U(C(U),C(U))><L,U(C(U),C(U))><S,1*U><L,1*U>,
     Inline: [0] -}
af1351ab5cca59308ff0417aba8b9c88
  clean ::
    (GHC.Classes.Eq k, GHC.Num.Num k, GHC.Classes.Eq (m u),
     GHC.Show.Show u, GHC.Classes.Ord (m u), GHC.Show.Show (m u),
     Math.Algebras.Structures.Algebra k (m u),
     Math.CommutativeAlgebra.Polynomial.MonomialConstructor m) =>
    Math.Algebras.VectorSpace.Vect k (m u)
    -> Math.Algebras.VectorSpace.Vect k (m u)
  {- Arity: 9,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><L,A><L,A><L,U(A,C(C1(U)),A,A,A,A,A,A)><L,A><L,U(C(U),C(U))><L,U(C(U),C(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (9, True, True)
                (\ @ k
                   @ (m :: * -> *)
                   @ u
                   (w :: GHC.Classes.Eq k)
                   (w1 :: GHC.Num.Num k)
                   (w2 :: GHC.Classes.Eq (m u))
                   (w3 :: GHC.Show.Show u)
                   (w4 :: GHC.Classes.Ord (m u))
                   (w5 :: GHC.Show.Show (m u))
                   (w6 :: Math.Algebras.Structures.Algebra k (m u))
                   (w7 :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w8 :: Math.Algebras.VectorSpace.Vect k (m u)) ->
                 PolAux.$wclean @ k @ m @ u w w1 w4 w6 w7 w8) -}
38dcfb90afa1299727c860d68cf977ec
  clean1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
25eb60d00e0997ae19d0ed4fdb5e7209
  deriv ::
    (GHC.Classes.Eq k, GHC.Classes.Eq u, GHC.Num.Num k,
     GHC.Classes.Ord (m u), GHC.Show.Show (m u),
     Math.Algebras.Structures.Algebra k (m u),
     Math.CommutativeAlgebra.Polynomial.MonomialConstructor m) =>
    Math.Algebras.VectorSpace.Vect k (m u)
    -> Math.Algebras.VectorSpace.Vect k (m u)
    -> Math.Algebras.VectorSpace.Vect k (m u)
  {- Arity: 9,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),C(C1(U)))><L,U(C(C1(U)),A,C(C1(U)),C(U),A,A,C(U))><L,U(1*U,C(C1(U)),A,A,A,A,A,A)><L,A><L,U(C(U),C(U))><L,U(C(U),C(U))><S,1*U><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (9, True, True)
                (\ @ k
                   @ u
                   @ (m :: * -> *)
                   (w :: GHC.Classes.Eq k)
                   (w1 :: GHC.Classes.Eq u)
                   (w2 :: GHC.Num.Num k)
                   (w3 :: GHC.Classes.Ord (m u))
                   (w4 :: GHC.Show.Show (m u))
                   (w5 :: Math.Algebras.Structures.Algebra k (m u))
                   (w6 :: Math.CommutativeAlgebra.Polynomial.MonomialConstructor m)
                   (w7 :: Math.Algebras.VectorSpace.Vect k (m u))
                   (w8 :: Math.Algebras.VectorSpace.Vect k (m u)) ->
                 PolAux.$wderiv @ k @ u @ m w w1 w2 w3 w5 w6 w7 w8) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

